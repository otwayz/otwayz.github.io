<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo 博客接入 Gitment 评论系统踩坑]]></title>
    <url>%2F2018%2F04%2F12%2FHexo%E5%8D%9A%E5%AE%A2%E6%8E%A5%E5%85%A5Gitment%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[本篇主要记录 Hexo 静态博客接入 Gitment 的步骤和踩坑。基于 github.io 的静态博客，NexT 是最新的 v6.1.0。 作者的文档: 使用 GitHub Issues 搭建评论系统 注册 OAuth Application 注意点。如果是 github.io 的静态博客，那么 callback URL 是 https://github.com , 如果是自己的域名，那么需要填写自己的。其他的配置应该是随意的，欢迎打脸 0.0 Error：validation failedIssue 的标签 Label 有长度限制！Labels 的最大长度限制是50个字符。 这个 id 的作用，就是针对一个文章有唯一的标识来判断这篇本章。 时间作为标签新增副标题作为标签 时间作为标签，每一个评论都是一个 Issue，甚至刷新页面都会有一个空的 Issue，所以不推荐。 副标题作为标签，没有尝试，但是每篇文章都要起一个副标题感觉没有必要。所以没有采用。 具体需要修改的位置： themes/next/layout/_third-party/comments/gitment.swig (source 27) 1id: window.location.pathname, // 默认设置 由于这个 pathname 会将汉字转换编码，导致字符长度过长。那么我的修改方案就是将编码再转换回去。 1id: window.decodeURIComponent(window.location.pathname), 只要标题不浪，该方案问题不大。 附上主题中 _config.yml 相关配置： 12345678910111213gitment: enable: true mint: false # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: true # Hide 'Powered by ...' on footer, and more language: en # Force language, or auto switch by theme github_user: 'otwayz(你的GitHub id)' # MUST HAVE, Your Github Username github_repo: 'BlogComments(你的评论仓库名称)' # MUST HAVE, The name of the repo you use to store Gitment comments client_id: （第一步注册的id） # MUST HAVE, Github client id for the Gitment client_secret: （第一步注册的secret） # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[白话 KMP 算法]]></title>
    <url>%2F2018%2F04%2F12%2F%E7%99%BD%E8%AF%9D-KMP-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[KMP 算法是计算机字符串匹配的常规算法。wiki本篇文章借助简单示例，用通俗易懂的方式描述对 KMP 算法的理解。 匹配值表对于 KMP 来说，“匹配值表”是很关键的。下面我们从简单示例出发描述匹配值表是如何产生的，以便理解。 现在 我们需要查找的字符串是 “ABABABCA”。 在描述“匹配值表“之前，我们需要简短的介绍下前缀和后缀的概念: 前缀：从 0 位，依次截取 1 到(len - 1)长度字符串的集合后缀：从 len - 1 位反序，依次截取 1 到(len - 1)长度字符串的集合 字符串 前缀集合 后缀集合 前缀后缀交集 “A” [] [] [] “AB” [A] [B] [] “ABA” [A,AB] [A, BA] [A] “ABAB” [A, AB, ABA] [B, AB, BAB] [AB] “ABABA” [A, AB, ABA, ABAB] [A, BA, ABA, BABA] [A, ABA] “ABABAB” [A, AB, ABA, ABAB, ABABA] [B, AB, BAB, ABAB, BABAB] [AB, ABAB] “ABABABC” [A, AB, ABA, ABAB, ABABA, ABABAB] [C, BC, ABC, BABC, ABABC, BABABC] [] “ABABABCA” [A, AB, ABA, ABAB, ABABA, ABABAB, ABABABC] [A, CA, BCA, ABCA, BABCA, ABABCA, BABABCA] [A] 从上表，如果耐心看，完全可以理解前缀和后缀的概念。 那么“匹配值”又是指什么呢？ “匹配值”是指前缀和后缀集合，最长共有元素的长度，即交集中最长元素的长度 那么不难从上表中得出每一位(index)字符对应“匹配值(value)”: 123char: | A | B | A | B | A | B | C | A |index:| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |value:| 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 | 匹配值表的使用我们可以根据匹配值表来加速查找匹配的过程。 下面还是举例说明问题： 在字符串”BACBABABAABCBABABABCA”(text)中查找上文中的字符串”ABABABCA”(pattern)，下文中对两个字符串的代称为括号之内的单词。 从 text 第一位开始匹配，第一次匹配成功是这样： 123BACBABABAABCBABABABCA | ABABABCA 那么开始往后匹配，发现 text 的第二位”C”和 pattern 的第二位”B”不匹配，所以当前部分匹配长度为1(只有一个A)，并且根据上文的匹配值表得到，当前的匹配值为 0。 移动位数 = 已匹配字符长度 - 对应位的匹配值 即 移动位数 = 1 - 0，所以我们继续向后移一位进行匹配。 再一次匹配成功的情形： 123BACBABABAABCBABABABCA ||||| ABABABCA 此时，text 中的”A”与 pattern 中的 “B” 不匹配，如果不按照算法，肯定是继续后移一位进行匹配。如果根据上述计算公式： 移动位数 = “ABABA”.length - pattern[4]的匹配值即 5 - 3 = 2 所以我们可以一次后移两位： 123BACBABABAABCBABABABCA xx||| ABABABCA 又不匹配了，此时应该后移 “ABA”.length - pattern[2]的匹配值即 3 - 1 = 2 继续后移两位： 123BACBABABAABCBABABABCA xx| ABABABCA 继续后移“A”.length - pattern[0]的匹配值即 1 - 0 = 1 后移一位： 123BACBABABAABCBABABABCA x|| ABABABCA 继续后移“AB”.length - pattern[1]的匹配值即 2 - 0 = 2 后移两位： 123BACBABABAABCBABABABCA xx| ABABABCA 第一位都不匹配，我们继续往后移动直到匹配成功 123BACBABABAABCBABABABCA |||||||| ABABABCA 移动几次之后(step=1)，找到了最终匹配结果。 参考：http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[混淆注意事项]]></title>
    <url>%2F2018%2F04%2F09%2F%E6%B7%B7%E6%B7%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[当 Debug 版本正常运行，Release 版本出现问题时，第一个想到的可能因素就应该是代码混淆导致的。 打包配置 开启 Debug在 build.gradle 中 buildType -&gt; release -&gt; debuggable true 混淆文件配置注意记录为主~ 防止声明混淆12-keepattributes *Annotation*-keepattributes JavascriptInterface]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>混淆</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程 ：Volatile]]></title>
    <url>%2F2018%2F04%2F06%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%EF%BC%9Avolatile%2F</url>
    <content type="text"><![CDATA[在多线程并发编程中，锁的运用很常见。synchronized 的几种运用方式，相信大部分 Java 程序员已经很熟悉。而 volatile 作为轻量级的 synchronized，不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销。 Volatile 的官方定义Java 语言规范第三版中对 volatile 的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了 volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。 内存不可见的含义在 JVM 中，对于多线程应用，如果多个线程同时使用某个没有 volatile 修饰的变量时，每个线程会从堆内存拷贝目标变量到当前线程所在的 CPU 的缓存中，然后针对这个 Cache 进行具体的操作。如果在多核设备上，多线程同时操作这个变量，可能存在两个线程运行在两个不同的 CPU 的情况，那么这两个线程所在的 CPU 将会存在各自的 CPU Cache。 这种情况下，从堆内存读取或者写入，都会存在一些问题。那么这个时候对于这两个线程来说，堆内存中的变量就是不可见的。 如何保证内存可见volatile 如何实现内存可见的呢？在x86处理器下通过工具获取JIT编译器生成的汇编指令： 语言 代码片段 Java instance = new Singleton(); //instance 是 volatile 修饰变量 汇编 0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp); 有 volatile 变量修饰的共享变量进行写操作的时候会多第二行汇编代码,通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。 将当前处理器缓存行的数据回写到系统内存。 这个回写内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。 也就是说，处理器为了提高处理速度，不直接和内存通讯，而是先将内存数据拷贝到缓存后再操作（同上图）。如果变量声明了 volatile，那么处理器读取操作会直接和内存进行通讯，将变量所在缓存行的数据直接写入系统内存或者直接读取系统内存数据。但是如果其他处理器缓存的数据仍然是旧的数据，那么再执行计算操作就是无意义的。所以这里就存在缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检测自身缓存是否过期，如果检测到自己缓存行对应的数据被修改，那么会将当前处理器缓存行设置为无效状态。当处理器需要该数据进行操作时，会强制从系统内存重新加载到当前处理器缓存中。 缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。 具体的专有名词及细节可以看文末的 reference（本节内容摘录自文末的参考文章）. 保证对 64 位变量读写的原子性JVM 可以保证对 32位 数据读写的原子性，但是对于 long 和 double 这样 64位 的数据的读写，会将其分为 高32位 和 低32位 分两次读写。所以对于 long 或 double 的读写并不是原子性的，这样在并发程序中共享 long 或 double 变量就可能会出现问题，于是 JVM 提供了 volatile 关键字来解决这个问题： 使用 volatile 修饰的 long 或 double 变量，JVM 可以保证对其读写的原子性。 但是，此处的 “写” 仅指对 64位 的变量进行直接赋值。而对于 i++ 这个语句，事实上涉及了 读取－修改－写入 三个操作： 读取变量到栈中某个位置 对栈中该位置的值进行自增 将自增后的值写回到变量对应的存储位置 所以多线程条件下使用 volatile 关键字的前提是：对变量的写操作不依赖于变量的当前值。 指令重新排序对 volatile 的影响如果一个操作不是原子操作，那么 JVM 便可能会对该操作涉及的指令进行 重排序。重排序即在不改变程序语义的前提下，通过调整指令的执行顺序，尽可能达到提高运行效率的目的。 12345int a = 1;int b = 2;a++;b++; 可能会被重新排序为： 12345int a = 1;a++;int b = 2;b++; 这样看是没什么影响的。 但当一个变量是 volatile 修饰时，指令重排序就可能会出现问题。 1234567891011public class Counter &#123; private int numA; private int numB private volatile int numC; public void update(int numA, int numB, int numC)&#123; this.numA = numA; this.numB = numB; this.numC = numC; &#125;&#125; 当 update 方法调用时，numA,numB,numC 的新值都会直接写入系统内存。但是如果重新排序成这样： 12345public void update(int numA, int numB, int numC)&#123; this.numC = numC; this.numA = numA; this.numB = numB;&#125; 修改 numC 变量时，A和B的值仍会写入主内存，但这一次是在A和B的新值写入之前发生的。因此，其他线程无法正确地看到A和B的新值。重新排序的指令的语义已经改变。 为了解决指令重新排序这个难题，Java volatile 关键字除了提供可见性保证之外，还提供“happens-before”保证： 如果读取/写入其他变量的操作最初就发生在写入 volatile 修饰变量之前，那么指令重新排序时，不允许这个操作被排到被 volatile 修饰的变量写入之后；注意,对于其他变量的操作最初发生在写入 volatile 修饰变量之后的，那么重新排序是仍然有可能排到 volatile 修饰变量写入之前。 如果读取/写入其他变量的操作最初就发生在写入 volatile 修饰变量之后，那么指令重新排序时，不允许这个操作被排到被 volatile 修饰的变量写入之前；注意,对于其他变量的操作最初发生在写入 volatile 修饰变量之前的，那么重新排序是仍然有可能排到 volatile 修饰变量写入之后。 上述的“happens-before”保证正在被实施。 volatile 并不保险对 volatile 修饰的变量操作时，即使每次都是从系统内存读取，都是直接写入系统内存，仍然会存在并发的情况。 当多个线程同时写入一个 volatile 变量时，例如 i++ 操作，第一个处理器缓存 i 进行了 +1 操作，还没来得及写入系统内存，第二个处理器页从系统内存中缓存了旧的 i 并且也完成了 +1 操作，并还没有写入系统内存。这时就会出现写入覆盖的情况。 合适的使用场景读取和写入一个 volatile 变量会直接和系统内存通信，对比与处理器缓存通信的消耗要大得多。访问 volatile 变量还防止指令重新排序，这是一种正常的性能增强技术。所以只有在真正需要变量强制可见性时才应该使用。 具体的几种场景可以参考正确使用 Volatile 变量 参考资料： http://www.infoq.com/cn/articles/ftf-java-volatile https://www.ibm.com/developerworks/cn/java/j-jtp06197.html http://tutorials.jenkov.com/java-concurrency/volatile.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯X5内核 WebView 实践总结]]></title>
    <url>%2F2018%2F02%2F22%2F%E8%85%BE%E8%AE%AFX5%E5%86%85%E6%A0%B8-WebView-%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本篇文章是基于 腾讯X5内核 WebView 实践的总结篇，较上篇文章更为完整，具体。 onPageFinished() 回调时机通过 WebView 的回调函数，分析 onPageFinished() 回调时机 加载某个网址的Android端回调监测如下： 123456789101112shouldOverrideUrlLoading time: 1519274808392onPageStarted: time: 1519274808561 // 169msonPageFinished time: 1519274809735 // 1174msonReadableCallback: falseshouldOverrideUrlLoading time: 1519274811067 --url :shanbay.native.app://document/readyonReadableCallback: trueonPageFinished time: 1519274817879 // 9318msonReadableCallback: true 据上数据分析：第一次onPageFinished()回调触发是在 1174ms (较onPageStarted()方法)第二次onPageFinished()回调触发是在 9318ms 通过 chrome://inspect监测的资源加载时序 Network 面板突出显示两种事件：DOMContentLoaded 和 load 解析页面的初始标记时会触发 DOMContentLoaded。 此事件将在Network 面板上的两个地方显示： Overview 窗格中的蓝色竖线表示事件。 在 Summary 窗格中，您可以看到事件的确切时间。 页面完全加载时将触发 load。此事件显示在三个地方： Overview 窗格中的红色竖线表示事件。 Requests Table 中的红色竖线也表示事件。 在 Summary 窗格中，您可以看到事件的确切时间。 分析上图： DOMContentLoaded 和 load 事件触发时机与Android端的回调触发时机不一致。 第一次onPageFinished()方法的调用和 document 类型文件加载完成时间相近，且经过多次测试是在该文件加载完成后调用。 第二次onPageFinished()方法回调时间和load时间相近。 初步总结： 第一次onPageFinished()方法是在document类型文件加载完成后调用的。 第二次onPageFinished()方法是在load完成时回调。 通过仔细查看shouldOverrideUrlLoading和onPageStarted方法时间差以及 图中 Overview 栏，会发现加载网页不是第一时间去请求数据的。所以 onPageStarted()方法较触发是有一定的延迟时间。 ready 替换 onPageFinished 实现据上分析的结果我们会发现，onPageFinished()方法会调用多次，所以，如果我们将业务逻辑放到该方法中执行，如果不做控制，势必会出现一些问题。当然，由于网页类型的多样性，即使做了控制，依然会在特定的页面出现问题。 那么我们如何摆脱对onPageFinished()的依赖呢？ 网页的加载状况，前端肯定会有生命周期的感知，那么我们为什么不依赖前端的通知来触发Native逻辑呢？ 通过上述的思考，Native的事件触发完全交给前端去主动调取，而不是通过不靠谱的WebView回调。在前端的$.ready()方法中去通知移动端开始执行业务逻辑。 并且这种方式在时序性能方面有很大提升，比第二次onPageFinished()触发时机早很多（在较为复杂的页面相差更大） 单页应用上面我们通过 ready() 的主动通知，实现了 onPageFinished() 方法中业务逻辑的优化。 但是，在单页应用的网页中，$.ready() 只在主页面渲染完成时触发一次，在子页面并不会触发，而且，WebView 的 shouldOverrideUrlLoading() 及 onPageStarted() 方法都不会回调。在一些单应用网页会触发 onPageFinished() 方法，它去请求了新的资源，所以我们感知到了回调。而个别网页并没有去请求新的资源，直接对资源进行了替换，这种情况，我们就感知不到 onPageFinished() 的回调。 当然，如果开发自己的页面就不存在这些多情况的处理，可以协商解决方案。 本文的主要实现是基于第三方网页做的功能扩展，所以需要考虑这些兼容性问题。 给出不成熟的参考方案： 前端 url 变化监听，通知移动端页面变化。 在 onPageFinished() 方法中再去做一个保底操作，损失一部分性能换取用户的响应速度。 Js 注入时机以及时序控制网络上的普遍做法是在 onPageFinished() 中注入 Js 脚本。 这种做法存在一些问题： 可能会注入多次。 onPageFinished()第二次调用时机很迟，在复杂的页面性能损失很大。 如果注入太多，会影响页面的体验。 由于项目注入的脚本行数达到 1W+，所以我们需要对时序做一些优化。保证调用时我们已经完成了注入。 这里我们主要注入生成一个 script 标签。 1234567891011webView.loadUrl("javascript:(function() &#123;" + "var scriptElement = document.getElementById('readability-script');" + "var parent = document.getElementsByTagName('body').item(0);" + "if(parent &amp;&amp; !scriptElement) &#123;" + "var script = document.createElement('script');" + "script.type = 'text/javascript';" + "script.id = 'readability-script';" + // Tell the browser to BASE64-decode the string into your script !!! "script.innerHTML = window.atob('" + mAssetsScript + "');" + "parent.appendChild(script);&#125;" + "&#125;)()"); 通过控制标签的唯一性来防止注入多次； 在页面初始化前完成本地 js 脚本的文件读取；不断尝试注入直到可以注入为止。 在 onProgressChanged() 回调中，不断的尝试读取节点注入脚本。 通过最开始对 onPageFinished() 的分析。是否可以尝试在第一次回调时开始注入脚本。但是，不能保证每个网页都会回调两次onPageFinished()。 通常情况下，CSS不会阻塞HTML的解析，但如果CSS后面有JS，则会阻塞JS的执行直到CSS加载完成（即便JS是内联的脚本），从而间接阻塞HTML的解析。 资源加载回调在研究WebView加载时序时发现了这个资源加载的回调onLoadResource()。这里简单介绍下，针对这个回调，可以做的事情很多。 在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。 12345webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean onLoadResource(WebView view, String url) &#123; &#125; &#125;); 可以实现预加载及手动缓存的功能。优化用户体验并且减少多次访问造成的流量浪费。 调试打造最舒适的 WebView 调试环境]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯X5内核 WebView 实践篇]]></title>
    <url>%2F2018%2F02%2F03%2F%E8%85%BE%E8%AE%AFX5%E5%86%85%E6%A0%B8-Webview-%E5%AE%9E%E8%B7%B5%E7%AF%87%2F</url>
    <content type="text"><![CDATA[基于腾讯X5内核的WebView开发：1.onPageFinished2.onProgressChanged()3.合适的时机获取页面元素 onPageFinished() 踩坑业务需求是在 html 中注入 js脚本实现阅读模式切换功能。但是基于开源项目 mozilla/readability 开发，项目脚本过长，如果不能选定合适的时机注入，那么势必会影响用户交互。 在实现需求阶段，实现方式是在 onPageFinished() 注入 js。注入代码完成之后，在页面 ready() 状态中主动去通知客户端当前页面内容加载完成，并且是否可以切换阅读模式。根据前端的状态返回来确定客户端的表现。当然，这个过程是缓慢的，所以不建议直接加载阅读模式的html 。 注入代码留存： 123456789101112131415161718192021222324252627private void injectScriptFile(X5WebView webView, String scriptFile) &#123; InputStream input; try &#123; input = getActivity().getAssets().open(scriptFile); byte[] buffer = new byte[input.available()]; input.read(buffer); input.close(); // String-ify the script byte-array using BASE64 encoding !!! String encoded = Base64.encodeToString(buffer, Base64.NO_WRAP); webView.loadUrl("javascript:(function() &#123;" + "var scriptElement = document.getElementById('readability-script');" + //"alert(scriptElement);" + "if(!scriptElement) &#123;" + "var parent = document.getElementsByTagName('head').item(0);" + "var script = document.createElement('script');" + "script.type = 'text/javascript';" +// "script.async = 'true';" + "script.id = 'readability-script';" + // Tell the browser to BASE64-decode the string into your script !!! "script.innerHTML = window.atob('" + encoded + "');" + "parent.appendChild(script);&#125;" + "&#125;)()"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 在功能完成之后，我们发现，有的网页出现解析代码运行之后通知客户端是可读的，但是我们并不能获取到展示的文本信息。导致切换阅读模式出现空白页面的情况。 这个Bug目前还没有解决，规避方案是当前页面的检测结果为可切换阅读模式页面并且可阅读文本不为空时，我们才会通知客户端该页面支持阅读模式的状态。我们目前选择了规避。 在页面调试时发现，上述的script标签内容导入了两次，虽然能够正常运行，但是无疑是增加了WebView消耗。 经过排查发现，在新网页开启时，会立即调用onPageStarted()和onPageFinished()方法，这个时候会第一次注入js,当页面完全加载完，WebView还是会回调一次onPageFinished()方法。那么这就是第二次的注入时机。上面的分析合情合理，但是真实原因并不是这个，因为我们发现在第一次onPageFinished()调用的时候，我们在注入js之后会去主动调用注入的一个方法，通过 chrome://inspect 调试发现，这个时候调用的方法是Undefined状态，所以说我们的注入是失败的。那么也就说明一个猜测，第一次回调onPageFinished()时，网页并没有完成html基本的格式加载。为什么在没有完成加载最基础的标签时，我们会收到onPageFinished()回调呢，这简直就是一个大坑，这个问题还没有深入研究，待后续再说吧。 排除了上述这个原因，那么为什么会出现js导入多次的情况呢？ 由于本人并不了解前端开发，所以出现这个问题才知晓了单页面应用的概念，具体的可以自行了解单页应用程序。 在单页面应用中，页面跳转中 &lt;header/&gt; 标签内容是一直存在的。在主页注入&lt;script/&gt;标签之后，在后续的onPageFinished()方法中重复导入。就会造成注入冗余的情况。 终于找到原因所在，那么上述的注入代码中，修改了js部分的代码，先去确定标签不存在再去注入。 总结：单页面应用在跳转时只会刷新&lt;body/&gt;内的信息，当然其他标签如果有更新也会变化，暂不考虑。而&lt;header/&gt;中注&gt;入js的动作执行了两次，所以导致了&lt;script/&gt;标签冗余。 这里还有个坑，在单页应用跳转时除了第一次加载外框页面会回调onPageStarted(),之后的内部页面跳转是没有这个回调的。 onProgressChanged()WebView 可以通过设置 WebChromeClient 来监听页面资源的加载情况，本文主要用onProgressChanged()方法。 在上面已经说过，需要注入的js过长，如果放在页面加载完成再去注入，是否很不合理。所以我们希望可以在页面加载过程中，去异步的注入。 最理想的状态是页面基本html加载完成之后，给客户端一个状态通知，然后这个时机去异步注入（想想罢了，不知道前端技术人员是否能够感知到这个状态）。 采取了大众方案，在onProgressChanged(WebView webView, int newProgress)回调的30%去注入。当然具体的进度值还需要自己去测试。 通过logcat你会发现，这里的进度显示也很诡异。 逼不得已，添加了一个flag来控制，在第一次导入开始时关闭，在onPageStarted()中打开。 时机既然WebView的回调方法这么不靠谱，那么我们就不能将核心功能依赖这两个不靠谱的方法。 由于阅读模式的检测是需要解析页面元素的，那么前端小伙伴是否能够在能够解析并解析完成之后将结果主动地下发到客户端呢？ 前端我只是了解了一个ready()的方法，是可以监听到页面加载完成的，前端发送一个跳转给客户端，客户端需要通过shouldOverrideUrlLoading(WebView webView, String url)方法主动去拦截前端的跳转，然后根据需求，可以去完成对应的具体功能。 这部分还在研究，看看前端是否有更加精准的方式来通知客户端。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView & NestedScrollView 嵌套收缩动画解决方案]]></title>
    <url>%2F2018%2F01%2F27%2FRecyclerView-NestedScrollView-%E5%B5%8C%E5%A5%97%E6%94%B6%E7%BC%A9%E5%8A%A8%E7%94%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在复杂的业务场景中，会利用到 NestedScrollView 嵌套好几个固定的布局来展示内容。在固定的布局中可能存在竖向的列表，并且要求列表完全展开。针对列表中的 Item 还需要赋予位置移动动画，整个列表收缩动画及展开动画。 情景说明本文针对该场景采取的是嵌套实现。 123456789101112131415161718192021222324252627282930313233343536&lt;android.support.v4.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/nested_scroll_view" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:fillViewport="true"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;LinearLayout android:id="@+id/container" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="300dp" android:background="@color/colorAccent"&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; 在上面的布局中，RecyclerView中是一个列表数据的展示，其中包含 位置移动，收缩，展开等操作。（PS：上述层级较多，只是为了测试层级对RecyclerView的影响，毕竟复杂场景不会只有一个RecyclerView 123456789val list = ArrayList&lt;Int&gt;()list += 1..20recycler_view.layoutManager = LinearLayoutManager(this)adapter = Adapter&lt;Int&gt;(list)recycler_view.adapter = adapterrecycler_view.itemAnimator = DefaultItemAnimator()recycler_view.itemAnimator.addDuration = 1000recycler_view.itemAnimator.removeDuration = 1000adapter!!.expand() 这里我们将动画的时长设置很长，便于观察。其中 Adapter 增加了收缩和展开的方法。 1234567891011121314151617private var maxCount = 0override fun getItemCount(): Int &#123; return minOf(dataList.size, maxCount)&#125;fun expand() &#123; val count = itemCount // 同 getItemCount() maxCount = Int.MAX_VALUE notifyItemRangeInserted(count, itemCount - count)&#125;fun collapse() &#123; val count = itemCount maxCount = 1 notifyItemRangeRemoved(1, count - itemCount)&#125; 简单的配置之后，我们发现。在展开动画开启时，RecyclerView 会伸缩到合适的高度以容纳 所有的 Item（这里设置了 android:fillViewport=&quot;true&quot; 的属性），然后我们才会看到默认的 add Item 的动画。但是，当我们收缩列表的时候，并没有观察到动画，给人的感觉是 直接 调用了 notifyDataSetChanged() 的方法。下面我们追踪一下源码来看看为什么会出现这种问题。 首先是 notifyItemRangeRemoved() 方法 123public final void notifyItemRangeRemoved(int positionStart, int itemCount) &#123; mObservable.notifyItemRangeRemoved(positionStart, itemCount);&#125; 根据该条代码进行追踪到最终实现的部分，在 RecyclerViewDataObserver 的实现中，我们找到了具体的实现逻辑。 12345678910111213141516@Override public void onItemRangeRemoved(int positionStart, int itemCount) &#123; assertNotInLayoutOrScroll(null); if (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) &#123; triggerUpdateProcessor(); &#125; &#125; void triggerUpdateProcessor() &#123; if (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) &#123; ViewCompat.postOnAnimation(RecyclerView.this, mUpdateChildViewsRunnable); &#125; else &#123; mAdapterUpdateDuringMeasure = true; requestLayout(); &#125; &#125; mHasFixedSize 字段的控制是关键所在，默认是false，所以直接进行了 requestLayout() 的操作，导致RecyclerView的高度直接变化到最小。 个人解决方案 如果列表的初始状态为完全展开状态。可以通过测量第一个Item高度，以及总高度 1234567recycler_view.post &#123; val viewFirst = recycler_view.layoutManager.findViewByPosition(0) firstItemHeight = viewFirst!!.height totalHeight = recycler_view.height&#125;//调用 adapter.collapse()或者 expand()的时候 调用 下面的方法。height(recycler_view, totalHeight.toFloat(), firstItemHeight.toFloat(), 1000, null) 只需要在收缩时 调用 height 的动画即可，展开也可以调用。 1234567891011121314151617fun height(view: View, from: Float, to: Float, duration: Int, animatorListener: Animator.AnimatorListener?): ValueAnimator &#123; val animator = ValueAnimator.ofFloat(from, to) animator.duration = duration.toLong() if (animatorListener != null) &#123; animator.addListener(animatorListener) &#125; animator.addUpdateListener &#123; animation -&gt; if (view.layoutParams != null) &#123; val lp = view.layoutParams val aFloat = animation.animatedValue as Float lp.height = aFloat.toInt() view.layoutParams = lp &#125; &#125; animator.start() return animator&#125; 通过设置 mHasFixedSize 属性 来达到目的 1234567891011if (iem.itemId == R.id.collapse) &#123; recycler_view.setHasFixedSize(true) it.collapse() recycler_view.postDelayed(&#123; recycler_view.setHasFixedSize(false) recycler_view.requestLayout() &#125;, recycler_view.itemAnimator.addDuration)&#125; else &#123; recycler_view.setHasFixedSize(false) it.expand()&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Menu]]></title>
    <url>%2F2017%2F12%2F10%2FAndroid-Menu%2F</url>
    <content type="text"><![CDATA[在使用 Android 版微信时发现，微信移除了侧滑操作，改为弹窗实现。个人对该方式很喜欢，所以对 Menu 的内容进行了整理。 选项菜单 OptionMenu12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@[+][package:]id/resource_name" android:title="string" android:titleCondensed="string" android:icon="@[package:]drawable/drawable_resource_name" android:onClick="method name" android:showAsAction=["ifRoom" | "never" | "withText" | "always" | "collapseActionView"] android:actionLayout="@[package:]layout/layout_resource_name" android:actionViewClass="class name" android:actionProviderClass="class name" android:alphabeticShortcut="string" android:alphabeticModifiers=["META" | "CTRL" | "ALT" | "SHIFT" | "SYM" | "FUNCTION"] android:numericShortcut="string" android:numericModifiers=["META" | "CTRL" | "ALT" | "SHIFT" | "SYM" | "FUNCTION"] android:checkable=["true" | "false"] android:visible=["true" | "false"] android:enabled=["true" | "false"] android:menuCategory=["container" | "system" | "secondary" | "alternative"] android:orderInCategory="integer" /&gt; &lt;group android:id="@[+][package:]id/resource name" android:checkableBehavior=["none" | "all" | "single"] android:visible=["true" | "false"] android:enabled=["true" | "false"] android:menuCategory=["container" | "system" | "secondary" | "alternative"] android:orderInCategory="integer" &gt; &lt;item /&gt; &lt;/group&gt; &lt;item &gt; &lt;menu&gt; &lt;item /&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; android:showAsAction ifRoom: Only place this item in the app bar if there is room for it never: overflow menu withText: only text android:title always: on the bar collapseActionView: android:actionLayout or android:actionViewClass android:actionViewClass 12345&lt;item android:id="@+id/action_search" android:title="@string/action_search" android:icon="@drawable/ic_search" app:showAsAction="ifRoom|collapseActionView" app:actionViewClass="android.support.v7.widget.SearchView" /&gt; 通过 setOnActionExpandListener() 监听展开收缩事件 android:actionViewLayout 引入布局用于操作窗口，效果类似于android:actionViewClass android:actionProviderClass 12345&lt;item android:id="@+id/action_share" android:title="share" app:showAsAction="always" app:actionProviderClass="android.support.v7.widget.ShareActionProvider" /&gt; 显示布局及可以监听相关事件 123456789101112131415161718@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); MenuItem shareItem = menu.findItem(R.id.action_share); if (searchItem != null) &#123; mShareActionProvider = (ShareActionProvider) MenuItemCompat.getActionProvider(shareItem); if (!setShareIntent())&#123; menu.removeItem(R.id.action_share); //没有第三方可以分享，可以自定义 //如果一个应用程序需要接受Share Intent发送的共享数据， // 那么需要在该应用程序的Manifest.xml文件中定义&lt;intent-filter/&gt;元素 //android.intent.action.SEND， // 指明应用组件想要接受的intent &#125; &#125; return super.onCreateOptionsMenu(menu); &#125; 123456789101112131415161718// Call to update the share intentprivate boolean setShareIntent() &#123; if (mShareActionProvider != null) &#123; Intent shareIntent = new Intent(Intent.ACTION_SEND); shareIntent.setType("text/plain"); shareIntent.putExtra(Intent.EXTRA_TEXT, "share content");//EXTRA_STREAM PackageManager pm = getPackageManager(); //检查手机上是否存在可以处理这个动作的应用 List&lt;ResolveInfo&gt; infoList = pm.queryIntentActivities(shareIntent, 0); if (!infoList.isEmpty()) &#123; mShareActionProvider.setShareIntent(shareIntent); return true; &#125; return false; &#125; return false;&#125; 这种会记录偏好，可通过setShareHistoryFileName()设置记录的xml文件名 设置setOnShareTargetSelectedListener监听条目点击事件 可继承support包下ActionProvider自定义实现android.support.design.R.dimen.abc_action_bar_default_height_material 关于overflow menu在高版本不显示icon安卓4.0之前会显示icon，高版本中不会显示，可以通过反射去设置icon的显示 1234567891011121314151617private void setIconEnable(Menu menu, boolean enable) &#123; if (menu != null) &#123; try &#123; Class clazz = menu.getClass(); if (clazz.getSimpleName().equals("MenuBuilder")) &#123; Method m = clazz.getDeclaredMethod("setOptionalIconsVisible", Boolean.TYPE); m.setAccessible(true); //MenuBuilder实现Menu接口，创建菜单时，传进来的menu其实就是MenuBuilder对象 m.invoke(menu, enable); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011121314/** * android 4.0以后使用AppCompatActivity必须在该方法中调用setIconEnable（）， * 隐藏的menuitem的icon才会显示 * android 4.0以后其他的activity可以再onPrepreOptionMenu()中调用 * android 4.0以前可以正常显示overflow中的menuitem的icon * @param view * @param menu * @return */@Overrideprotected boolean onPrepareOptionsPanel(View view, Menu menu) &#123; setIconEnable(menu, true);//让在overflow中的menuitem的icon显示 return super.onPrepareOptionsPanel(view, menu);&#125; 手机实体菜单按键导致actionbar上的三个点图标不显示1234567891011121314151617/** * 通过反射，设置实体menu键可用与否 * 该方法在onCreate（）中调用 * @param enable false:实体键不可用，会在actionbar上显示小点 * true：可用，点击menu实体键才会显示menuitem */public void setHasPermanentMenuKey(boolean enable)&#123; try &#123; ViewConfiguration mconfig = ViewConfiguration.get(this); Field menuKeyField = ViewConfiguration.class.getDeclaredField("sHasPermanentMenuKey"); if(menuKeyField != null) &#123; menuKeyField.setAccessible(true); menuKeyField.setBoolean(mconfig, enable); &#125; &#125; catch (Exception ex) &#123; &#125;&#125; 可以通过自定义toolbar中布局实现理想效果1234567ActionBar actionBar = getSupportActionBar();//设置自定义actionbar的viewactionBar.setCustomView(R.layout.action_bar_layout);//设置展示的options为DISPLAY_SHOW_CUSTOMactionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);//设置showCustom为trueactionBar.setDisplayShowCustomEnabled(true); 上下文菜单 ContextMenu浮动上下文菜单 registerForContextMenu(View view)注册于上下文菜单关联的View Activity 或 Fragment实现 registerForContextMenu()，当关联的View收到长按事件之后，会响应该方法。 1234567@Overridepublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) &#123; super.onCreateContextMenu(menu, v, menuInfo); MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.context_menu, menu);&#125; 事件监听 123456789@Overridepublic boolean onContextItemSelected(MenuItem item) &#123; AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo(); switch (item.getItemId()) &#123; //TODO default: return super.onContextItemSelected(item); &#125;&#125; 为单个视图启用上下文操作模式 实现 ActionMode.Callback 接口。在其回调方法中，您既可以为上下文操作栏指定操作，又可以响应操作项目的点击事件，还可以处理操作模式的其他生命周期事件 当需要显示操作栏时，调用activity的startActionMode()方法 弹出菜单 PopupMenu123456public void showPopup(View v) &#123; PopupMenu popup = new PopupMenu(this, v); MenuInflater inflater = popup.getMenuInflater(); inflater.inflate(R.menu.actions, popup.getMenu()); popup.show();&#125; 通过setOnMenuItemclickListener()设置监听 基于 Intent 的菜单项通过intent_filter定义删选规则 CATEGORY_ALTERNATIVE 和 CATEGORY_SELECTED_ALTERNATIVE 调用Menu.addIntentOptions()来添加应用列表 ListPopupMenu1234567891011121314151617181920212223242526final ListPopupWindow popup = new ListPopupWindow(mContext);List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("不喜欢");list.add("举报");popup.setBackgroundDrawable(new ColorDrawable(Color.WHITE));popup.setAdapter(new ArrayAdapter&lt;&gt;(mContext, R.layout.biz_elevator_layout_note_popup_item, list));popup.setWidth( mContext.getResources().getDimensionPixelSize(R.dimen.width40));popup.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT);popup.setAnchorView(mUserLayout);popup.setModal(true);popup.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; switch (position) &#123; case 0: break; case 1: break; &#125; popup.dismiss(); &#125;&#125;);popup.setHorizontalOffset(-40);popup.setDropDownGravity(Gravity.END);popup.show(); PopupWindow123456789101112131415161718192021222324252627282930313233final PopupWindow popupWindow = new PopupWindow(mContext);View inflate = LayoutInflater.from(mContext).inflate(R.layout.biz_elevator_layout_note_item_popup, null);View tvDislike = inflate.findViewById(R.id.popup_dislike);View tvReport = inflate.findViewById(R.id.popup_report);tvDislike.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mCallback != null) &#123; mCallback.onDisLikeClicked(v, mPosition); &#125; popupWindow.dismiss(); &#125;&#125;);tvReport.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mCallback != null) &#123; mCallback.onReportClicked(v, mPosition); &#125; popupWindow.dismiss(); &#125;&#125;);popupWindow.setContentView(inflate);popupWindow.setWidth(ViewGroup.LayoutParams.WRAP_CONTENT);popupWindow.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT);popupWindow.setBackgroundDrawable(new ColorDrawable(Color.WHITE));// this setting can intercept the touch event when popupWindow openedpopupWindow.setFocusable(true);popupWindow.setTouchable(true);popupWindow.setOutsideTouchable(true);PopupWindowCompat.showAsDropDown(popupWindow, v, -50, 10, Gravity.LEFT);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>menu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh[Oh My Zsh]]]></title>
    <url>%2F2017%2F12%2F10%2Fzsh-Oh-My-Zsh%2F</url>
    <content type="text"><![CDATA[iTerm2 中对于分支的显示方案并不是很人性化。通过安装 Oh-My-Zsh 对分支控制了然于胸。本篇文章主要介绍 Oh-My-Zsh 的安装以及主题搭配方案。感兴趣的同学可以参照着配置自己喜欢的主题样式 安装 12345678git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh# Backup your existing ~/.zshrc file: optionalcp ~/.zshrc ~/.zshrc.orig# Recommendcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrcsource ~/.zshrc# Change your default shellchsh -s /bin/zsh 主题配置 采用的是powerlevel9k主题，色系是Neutron 以下是安装 powerline 以及解决字体乱码问题 12345678910111213141516pip install --user powerline-status# Download fonts and font config.wget https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otfwget https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf# Linuxmv PowerlineSymbols.otf ~/.fonts/# Update font cache for the path the font was moved to.fc-cache -vf ~/.fonts/# Install the fontconfig file.mv 10-powerline-symbols.conf ~/.config/fontconfig/conf.d/# Mac OS X# You can click the PowerlineSymbols.otf to install or you can move the file to font dir like:mv PowerlineSymbols.otf /Library/Fonts/ 字体安装完毕之后，需要: 配置色系 Launch iTerm 2. Get the latest version at iterm2.com Type CMD+i (⌘+i) Navigate to Colors tab Click on Load Presets Click on Import Save the neutron.itermcolors file Click on Load Presets and choose neutron 配置字体 Navigate to Text tab Click Change Font Search PowerlineSymbols and select to use 样式配置(在~/.zshrc中添加): 12345POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir vcs)POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status time)POWERLEVEL9K_TIME_FORMAT="%D&#123;%H:%M:%S&#125;"POWERLEVEL9K_NODE_VERSION_BACKGROUND='022'POWERLEVEL9K_SHORTEN_DIR_LENGTH=1 更多可参看: 主题、色系 ps: 由于 git 是默认安装的插件，而且 ~/.zshrc 中是默认的高亮，满足了基本使用。如果需要安装插件，请自行 google 。刚接触的时候，迷恋插件，然后找到 Github 上的脚本安装，将 Vim 打造成了炫酷的 IDE 效果，由于不熟悉操作，放弃之，自此远离非必要插件，需求驱动安装插件我觉得是新手最佳选择.]]></content>
      <tags>
        <tag>Tools</tag>
        <tag>iTerm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android MAT分析内存]]></title>
    <url>%2F2015%2F01%2F27%2FAndroid-MAT%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[本篇文章是第一次分析 App 内存的一次记录，使用了一些简单的 adb 命令以及 MAT 工具对内存文件进行分析，对简单的一些内存问题进行了举例说明。这篇文章第一次发布在 CSDN ，由于 CSDN 已长期不维护，所以迁移到此处。 最近还会对内存进行深入研究，所以自己也顺带看看以前的青涩思路。 内存分析使用adb dumpsys 命令adb是一个非常强大的工具，使用adb查看应用程序内存使用情况可按如下格式在命令行里查看内存使用情况：adb shell dumpsys meminfo &lt;package_name&gt; 还有些有用的命令 adb shell dumpsys activity—————查看ActvityManagerService 所有信息 adb shell dumpsys activity activities———-查看Activity组件信息 adb shell dumpsys activity services———–查看Service组件信息 adb shell dumpsys activity providers———-产看ContentProvider组件信息 adb shell dumpsys activity broadcasts——–查看BraodcastReceiver信息 adb shell dumpsys activity intents————–查看Intent信息 adb shell dumpsys activity processes———查看进程信息 其中，package_name 也可以换成程序的pid，pid可以通过 adb shell top | grep app_name 来查找 重点关注如下几个字段： （1） Native/Dalvik 的 Heap 信息具体在上面的第一行和第二行，它分别给出的是JNI层和Java层的内存分配情况，如果发现这个值一直增长，则代表程序可能出现了内存泄漏。 （2） Total 的 PSS 信息这个值就是你的应用真正占据的内存大小，通过这个信息，你可以轻松判别手机中哪些程序占内存比较大了。 命令输入后还有以下信息： 横竖屏或者切屏观察activity数目变化，Activity发生重建且上面标记处数目增加，那么就表示该activity未被回收，存在内存泄漏。 * 导出的文件并不能直接被MAT工具解析，需要用工具转换。工具地址：D:\sdk\tools\hprof-conv.exe 命令输入： D:\sdk\tools\hprof-conv.exe D:\mat_any\com.lenovo.tabletstore.hprof D:\mat_any\my.hprof 工具路径---&gt;直接导出文件的路径---&gt;希望转换后存储文件名及路径 接下来用MAT分析该文件，下载地址 ；文档介绍 内存泄漏分析通过对网上资料整理，发现还是下面的方法比较简洁好用 打开MAT找到标记按钮，输入查找数据库指令 select * from instanceof android.app.Activity 按Ctrl + F5或者! 或者 F5 操作可以参考 这篇文章 ：使用Android studio分析内存泄露 个人建议：如果搜索出来的同一个activity只有一个（前提是确定该activity确实发生多次重建），那么可以忽略，但是最好还是看下是否有自己熟悉的泄漏；如果存在多个相同的activity，那么理论上 这个字段小的 是应该被回收的Activity。所以要选中这些应被回收而未被回收的Activity进行上述的操作 右键–&gt;Path To Gc Roots –&gt; exclude weak/soft reference 提供本人遇到的几个泄漏问题： Context 被引用，未被回收，所以在能用ApplicationContext的地方尽量使用ApplicationContext 使用场景参考 http://blog.csdn.net/lmj623565791/article/details/40481055 Android Context 上下文 你必须知道的一切 Listener 自己添加的 需要自己去解除引用 使用弱引用时应该注意返回弱引用中取出的对象，将强引用释放，而不是直接返回强引用对象 最后需要根据分析的结果去排查泄漏的地方，如果看不懂分析结果，可以自己拿到该对象去代码中排查，对每一个引用点进行细致分析，是否会存在异步问题导致比Activity生命周期存在时间长而产生内存泄漏，以及存储的集合是否需要手动清空等等…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>memory</tag>
        <tag>MAT</tag>
      </tags>
  </entry>
</search>
