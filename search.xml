<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Head First设计模式——装饰者模式</title>
      <link href="/2019/01/09/HeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/09/HeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>本文是阅读 Head First 设计模式——装饰者模式的总结。<br>这本书的教学模式很不错，个人很喜欢，由实际的案例由浅入深，循序渐进的让你明白良好的设计是多么的优雅迷人（回头看看自己的代码，WTF！）。<br>但是读第二遍的时候，居然想不起来这章节说了什么，到底怎么解决这个问题的。也就是说，看的时候爽快，看完了并没有应用到具体的Coding中。</p><p>这一章节的案例是：设计星巴兹咖啡系统</p><a id="more"></a><blockquote><p>相关的背景：<br>星巴兹咖啡现在有四种咖啡：黑咖啡(HouseBlend)、深度烘焙咖啡(DarkRoast)、脱咖啡因咖啡(Decaf)、浓咖啡(Espresso)。<br>用户在购买咖啡时，可以要求在其中加入各种调料，例如：蒸奶（Steamed Milk）、豆浆（Soy）、摩卡（Mocha）或覆盖奶泡（Whip）。会根据所加入的调料收取不同的费用，所以订单系统必须考虑到这些调料的价格。</p></blockquote><h2 id="原先的类设计"><a href="#原先的类设计" class="headerlink" title="原先的类设计"></a>原先的类设计</h2><p><img src="https://res.cloudinary.com/otway/image/upload/v1547024867/coffee_origin_class.png" alt="类图"></p><p>如果按照这种模式，在某种咖啡中加入调料，那么就是一个新的子类，继承 <code>Beverage</code> ，实现自己的 <code>cost()</code> 方法，算出咖啡以及调料的价格。以此类推，这是一个类爆炸的系统，有多少种花样就要为此设计多少类。</p><p>很明显，星巴兹为自己制作了一个维护噩梦。如果牛奶涨价了，怎么办？新增一种焦糖风味调料时，怎么办？</p><p>很明显，这种设计是有致命的缺陷的。</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>利用实例变量和继承，可以追踪调料，没必要去设计这么多类。</p><p><img src="https://res.cloudinary.com/otway/image/upload/v1547027379/coffee_extends_sample.png" alt="类图"></p><p>这样设计有哪些缺陷呢？</p><ul><li>调料价格变化时，需要更改现有代码</li><li>出现新的调料，需要添加新的方法，并改动超类中的<code>cost()</code>方法</li><li>以后开发新的饮料，对于这些饮料，某些调料并不适合，但是这个设计中，子类仍需继承那些不需要的方法</li><li>万一顾客想要双倍摩卡怎么办？</li></ul><p><strong>当然这种设计，违反了基本的<a href="https://baike.baidu.com/item/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">开闭原则</a>，类应该对扩展开放，对修改关闭。</strong></p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>从上面的方案来看，我们利用继承无法完全解决问题，现在遇到的问题有：类数量爆炸、设计死板，以及基类加入的新功能并不适用所有的子类。</p><p>所以，在这里要采用不一样的做法：以饮料为主体，然后再运行时以调料来“装饰”（decorate）饮料。比如，如果顾客想要摩卡和奶泡深焙咖啡,那么，要做的是：</p><ol><li>拿一个深焙咖啡（DarkRoast）对象</li><li>以摩卡(Mocha）对象装饰它</li><li>以奶泡（Whip）对象装饰它</li><li>调用<code>cost()</code>方法，并依赖委托将调料的价钱加上去</li></ol><p><img src="https://res.cloudinary.com/otway/image/upload/v1547091546/coffee_order_1.png" alt="订单构成1"><br><img src="https://res.cloudinary.com/otway/image/upload/v1547091545/coffee_order_2.png" alt="订单构成2"></p><p>上面是pdf文本的截图，这个过程如果不画出来，就漏掉了很重要的循序渐进的过程。</p><blockquote><p><strong>装饰者模式</strong>：动态的将责任附加到对象上。若是要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p></blockquote><p><img src="https://res.cloudinary.com/otway/image/upload/v1547103499/coffee_design_patterns_observer.png" alt="装饰者模式结构"></p><p>上图是装饰者模式的结构类图。</p><p>废话不多说，看看我们的订单系统该如何写。</p><p>原始的类图中，超类Beverage基本不用改动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    String description = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面实现调料类的抽象类，也就是装饰者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了让CondimentDecorator 能够取代 Beverage，所有才继承Beverage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是饮料实体类，按照上面的包装图例，我们就实现<code>DarkRoast</code>就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkRoast</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DarkRoast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        description = <span class="string">"DarkRoast"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是Mocha 和 Whip 的调料代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", Mocha"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.20</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Whip</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", Whip"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.10</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，依照装饰者模式，我们完成了基本的代码实现。下面是测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarbuzzCoffee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一杯DarkRoast，不需要调料</span></span><br><span class="line">        Beverage beverage = <span class="keyword">new</span> DarkRoast();</span><br><span class="line">        System.out.println(beverage.getDescription() + <span class="string">" $"</span> + beverage.cost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一杯DarkRoast，加双份Mocha和奶泡</span></span><br><span class="line">        Beverage beverage2 = <span class="keyword">new</span> DarkRoast();</span><br><span class="line">        beverage2 = <span class="keyword">new</span> Mocha(beverage2);</span><br><span class="line">        beverage2 = <span class="keyword">new</span> Mocha(beverage2);</span><br><span class="line">        beverage2 = <span class="keyword">new</span> Whip(beverage2);</span><br><span class="line">        System.out.println(beverage2.getDescription() + <span class="string">" $"</span> + beverage2.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DarkRoast $<span class="number">1.99</span></span><br><span class="line">DarkRoast, Mocha, Mocha, Whip $<span class="number">2.49</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>真实世界的装饰者：Java I/O</strong></p><p>文章本来是打算简单的总结下该章节的内容，方便以后资料的查找，回忆下知道大概讲的是什么东西，写下来发现，如果不能够将这个循序渐进的过程写下来，那么就失去这本书基本的宗旨。<br>上面的内容基本都是章节的文本，主要是担心自己理解误导了读者。</p><p>如果对文章的内容感兴趣，不妨去读一下《Head First设计模式》。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单易用的状态栏 - Softbar</title>
      <link href="/2018/11/12/%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%8F-Softbar/"/>
      <url>/2018/11/12/%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%8F-Softbar/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沉浸式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DashPathEffect not working</title>
      <link href="/2018/05/22/DashPathEffect-not-working/"/>
      <url>/2018/05/22/DashPathEffect-not-working/</url>
      <content type="html"><![CDATA[<p>由于公司的文字渲染引擎是自己实现的，在对单词进行标识时用到了虚线下划线的效果，通过 <code>Paint</code> 设置 <code>setPathEffect()</code> 方法，其中 <code>DashPathEffect</code> 类是官方提供的设置虚线的显示效果。在源码注释中明确说明 <code>Paint</code> 的 style 设置成 <code>STROKE</code> or <code>FILL_AND_STROKE</code> 才会生效。最近发现在高版本的 Android 设备（8.0）上，原本应该显示的虚线变成了实线。</p><a id="more"></a><p>官方的 API 在最新的 Android P 中并未对 <code>DashPathEffect</code> 类的说明进行修改</p><blockquote><p>The intervals array must contain an even number of entries (&gt;=2), with the even indices specifying the “on” intervals, and the odd indices specifying the “off” intervals. phase is an offset into the intervals array (mod the sum of all of the intervals). The intervals array controls the length of the dashes. The paint’s strokeWidth controls the thickness of the dashes. Note: this patheffect only affects drawing with the paint’s style is set to STROKE or FILL_AND_STROKE. It is ignored if the drawing is done with style == FILL.</p></blockquote><p>然而，莫名其妙的在高版本失效，肯定是版本导致的问题。</p><p>在 <code>Paint</code> 中的 <code>setPathEffect()</code> 方法都是调用 Native 方法实现的，未能看到具体的实现逻辑。</p><p>所以只能尝试修改 <code>Paint</code> 的一些设置。</p><p>最终发现， style 设置成 <code>FILL_AND_STROKE</code> 是无效的， 设置成 <code>STROKE</code> 才能在高版本中完美展示虚线效果。</p><p>虽然是一个很小的问题，但是文档没有更新真心很坑。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>死锁防御战</title>
      <link href="/2018/04/20/%E6%AD%BB%E9%94%81%E9%98%B2%E5%BE%A1%E6%88%98/"/>
      <url>/2018/04/20/%E6%AD%BB%E9%94%81%E9%98%B2%E5%BE%A1%E6%88%98/</url>
      <content type="html"><![CDATA[<p>在某些应用场景下，能够做到预防死锁的发生。本文会描述三种情形：</p><ol><li>Lock Ordering</li><li>Lock Timeout</li><li>Deadlock Detection</li></ol><a id="more"></a><h2 id="Lock-Ordering"><a href="#Lock-Ordering" class="headerlink" title="Lock Ordering"></a>Lock Ordering</h2><p>多个线程需要相同的锁来完成代码顺畅运行，但是访问锁的顺序是不同的，那么就可能会发生死锁的情况。</p><p>也就是说，如果多个线程需要相同的锁，但是他们对锁的访问顺序是相同的，那么就不可能会出现死锁的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread 1:</span><br><span class="line">    lock A</span><br><span class="line">    lock B</span><br><span class="line"></span><br><span class="line">Thread 2:</span><br><span class="line">    <span class="built_in">wait</span> <span class="keyword">for</span> A</span><br><span class="line">    lock C (when A locked)</span><br><span class="line"></span><br><span class="line">Thread 3:</span><br><span class="line">    <span class="built_in">wait</span> <span class="keyword">for</span> A</span><br><span class="line">    <span class="built_in">wait</span> <span class="keyword">for</span> B</span><br><span class="line">    <span class="built_in">wait</span> <span class="keyword">for</span> C</span><br></pre></td></tr></table></figure><p>如果现在有一个线程，需要多个锁（和 Thread 3 类似），它必须要找既定的顺序去获取锁，它不能在没获取前面锁的情况下（例如:A）去获取排在后面的锁（例如:B）。</p><p><strong>“锁排序”是一种简单而有效的死锁预防机制。但是，只有在获取任何锁之前就知道所需的所有锁才能使用这种方式防御。</strong></p><h2 id="Lock-Timeout"><a href="#Lock-Timeout" class="headerlink" title="Lock Timeout"></a>Lock Timeout</h2><p>另一个死锁预防机制是<strong>对尝试“获取锁”设置超时时长，这意味着尝试获取锁的线程只会在放弃之前阻塞这么长的时间。</strong></p><p>如果一个线程在给定的超时时间内仍没有成功获取所有必要的锁，那么它将阻塞并释放所有已持有的锁，等待一段随机时间，然后重试。</p><p>等待的随机时间用于让其他线程尝试获取相同的锁，从而让应用程序继续运行而不阻塞。</p><p>下面的例子就是两个线程尝试以不同的顺序获取相同的锁，然后线程阻塞和重试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 locks A</span><br><span class="line">Thread 2 locks B</span><br><span class="line"></span><br><span class="line">Thread 1 attempts to lock B but is blocked</span><br><span class="line">Thread 2 attempts to lock A but is blocked</span><br><span class="line"></span><br><span class="line">Thread 1<span class="string">'s lock attempt on B times out</span></span><br><span class="line"><span class="string">Thread 1 backs up and releases A as well</span></span><br><span class="line"><span class="string">Thread 1 waits randomly (e.g. 257 millis) before retrying.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thread 2'</span>s lock attempt on A <span class="built_in">times</span> out</span><br><span class="line">Thread 2 backs up and releases B as well</span><br><span class="line">Thread 2 waits randomly (e.g. 43 millis) before retrying.</span><br></pre></td></tr></table></figure><p>上例中，Thread 2 比 Thread 1 先 200ms 进行重新尝试并且在这种情况下很大可能会成功获取两个必要锁。Thread 1 将继续等待 lock A。当Thread 2运行结束，Thread 1 也能够获取两个锁。（除非Thread 2 或者其他线程在又开始插足锁得获取）</p><blockquote><p>注：锁超时并不意味着线程已经死锁，也可能意味着持有锁的线程（导致另一个线程超时）需要很长的时间来完成它的任务。</p></blockquote><p>另外，如果有很多的线程竞争相同的资源，他们仍然有可能多次的同时重试，即使超时和阻塞。这种情况在两个线程在重试之前等待0到500ms可能不会发生，但是如果是10到20个线程，那么情况就不一样了。它和两个线程等待相用时间或者近乎相同的时间再重试的情况差不多。</p><p>但是，锁的超时机制并不能在Java的同步代码块中设置超时，你将不得不创建自定义锁类或使用java.util.concurrency包中的一个Java 5并发结构，编写自定义锁并不困难，但超出本文范围，有兴趣的自行了解。</p><h2 id="Deadlock-Detection"><a href="#Deadlock-Detection" class="headerlink" title="Deadlock Detection"></a>Deadlock Detection</h2><p><strong>死锁检测是一种较重的死锁防御机制，针对无法获取锁顺序和锁超时不可行的情况。</strong></p><p>每当线程<strong>takes</strong>锁时，都会在线程和锁的数据结构中注明。另外，线程<strong>requests</strong>锁也会在数据结构中注明。</p><p>当线程请求锁的请求被拒绝时，线程可以遍历锁图来检查死锁。例如，如果线程A请求 lock 7，但是 lock 7被线程B持有，线程A会检测线程B是否请求线程A已经持有的锁（如果有）。如果线程B请求是线程A已经持有的锁，则发生死锁。</p><p>当然，大部分情况会更加复杂，往往都是多个线程造成死锁。</p><p>那么发现线程死锁该如何做呢?</p><p>一种可能的操作时释放所有锁，阻塞等待一段随机时间，然后重试。这和更简单的锁超时机制类似，只是线程仅在确定发生死锁的时候进行阻塞，而不仅根据发生锁超时来判断。但是，如果很多线程正在争夺相同的锁，即使它们阻塞并等待，它们也可能会重复地陷入僵局。</p><p>一个更好的选择是确定和分配线程的优先级，以便于阻塞一个（或几个）线程，其余的线程继续获取他们所需的锁，就像没有死锁发生一样。如果分配给线程的优先级是固定的，相同的线程将总是被富裕更高的优先级。为了避免这种情况，可以在检测死锁时随机分配优先级。</p><p>原文链接:</p><p>  <a href="http://tutorials.jenkov.com/java-concurrency/deadlock-prevention.html#timeout" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-concurrency/deadlock-prevention.html#timeout</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lock </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 博客接入 Gitment 评论系统踩坑</title>
      <link href="/2018/04/12/Hexo%E5%8D%9A%E5%AE%A2%E6%8E%A5%E5%85%A5Gitment%E8%B8%A9%E5%9D%91/"/>
      <url>/2018/04/12/Hexo%E5%8D%9A%E5%AE%A2%E6%8E%A5%E5%85%A5Gitment%E8%B8%A9%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>本篇主要记录 Hexo 静态博客接入 Gitment 的步骤和踩坑。基于 github.io 的静态博客，NexT 是最新的 v6.1.0。</p><a id="more"></a><p>作者的文档: <a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">使用 GitHub Issues 搭建评论系统</a></p><h2 id="注册-OAuth-Application-注意点。"><a href="#注册-OAuth-Application-注意点。" class="headerlink" title="注册 OAuth Application 注意点。"></a>注册 OAuth Application 注意点。</h2><p>如果是 github.io 的静态博客，那么 callback URL 是 <a href="https://github.com">https://github.com</a> , 如果是自己的域名，那么需要填写自己的。<br>其他的配置应该是随意的，欢迎打脸 0.0</p><h2 id="Error：validation-failed"><a href="#Error：validation-failed" class="headerlink" title="Error：validation failed"></a>Error：validation failed</h2><p>Issue 的标签 Label 有长度限制！Labels 的最大长度限制是50个字符。</p><p>这个 id 的作用，就是针对一个文章有唯一的标识来判断这篇本章。</p><p><a href="http://xichen.pub/2018/01/31/2018-01-31-gitment/" target="_blank" rel="noopener">时间作为标签</a><br><a href="http://www.xjdesyxx.top/2018/02/07/errsln/" target="_blank" rel="noopener">新增副标题作为标签</a></p><p>时间作为标签，每一个评论都是一个 Issue，甚至刷新页面都会有一个空的 Issue，所以不推荐。</p><p>副标题作为标签，没有尝试，但是每篇文章都要起一个副标题感觉没有必要。所以没有采用。</p><p>具体需要修改的位置： themes/next/layout/_third-party/comments/gitment.swig (source 27)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: window.location.pathname, // 默认设置</span><br></pre></td></tr></table></figure><p>由于这个 pathname 会将汉字转换编码，导致字符长度过长。那么我的修改方案就是将编码再转换回去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: window.decodeURIComponent(window.location.pathname),</span><br></pre></td></tr></table></figure><p>只要标题不浪，该方案问题不大。</p><p>附上主题中 _config.yml 相关配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitment:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  mint:</span> <span class="literal">false</span> <span class="comment"># RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span></span><br><span class="line"><span class="attr">  count:</span> <span class="literal">true</span> <span class="comment"># Show comments count in post meta area</span></span><br><span class="line"><span class="attr">  lazy:</span> <span class="literal">false</span> <span class="comment"># Comments lazy loading with a button</span></span><br><span class="line"><span class="attr">  cleanly:</span> <span class="literal">true</span> <span class="comment"># Hide 'Powered by ...' on footer, and more</span></span><br><span class="line"><span class="attr">  language:</span> <span class="string">en</span> <span class="comment"># Force language, or auto switch by theme</span></span><br><span class="line"><span class="attr">  github_user:</span> <span class="string">'otwayz(你的GitHub id)'</span> <span class="comment"># MUST HAVE, Your Github Username</span></span><br><span class="line"><span class="attr">  github_repo:</span> <span class="string">'BlogComments(你的评论仓库名称)'</span> <span class="comment"># MUST HAVE, The name of the repo you use to store Gitment comments</span></span><br><span class="line"><span class="attr">  client_id:</span> <span class="string">（第一步注册的id）</span> <span class="comment"># MUST HAVE, Github client id for the Gitment</span></span><br><span class="line"><span class="attr">  client_secret:</span> <span class="string">（第一步注册的secret）</span> <span class="comment"># EITHER this or proxy_gateway, Github access secret token for the Gitment</span></span><br><span class="line"><span class="attr">  proxy_gateway:</span> <span class="comment"># Address of api proxy, See: https://github.com/aimingoo/intersect</span></span><br><span class="line"><span class="attr">  redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint enabled</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>白话 KMP 算法</title>
      <link href="/2018/04/12/%E7%99%BD%E8%AF%9D-KMP-%E7%AE%97%E6%B3%95/"/>
      <url>/2018/04/12/%E7%99%BD%E8%AF%9D-KMP-%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>KMP 算法是计算机字符串匹配的常规算法。<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">wiki</a><br>本篇文章借助简单示例，用通俗易懂的方式描述对 KMP 算法的理解。</p><a id="more"></a><h1 id="匹配值表"><a href="#匹配值表" class="headerlink" title="匹配值表"></a>匹配值表</h1><p>对于 KMP 来说，“匹配值表”是很关键的。下面我们从简单示例出发描述匹配值表是如何产生的，以便理解。</p><p>现在 我们需要查找的字符串是 “ABABABCA”。</p><p>在描述“匹配值表“之前，我们需要简短的介绍下前缀和后缀的概念:</p><p>前缀：从 0 位，依次截取 1 到(len - 1)长度字符串的集合<br>后缀：从 len - 1 位反序，依次截取 1 到(len - 1)长度字符串的集合</p><table><thead><tr><th style="text-align:left">字符串</th><th style="text-align:left">前缀集合</th><th style="text-align:left">后缀集合</th><th style="text-align:left">前缀后缀交集</th></tr></thead><tbody><tr><td style="text-align:left">“A”</td><td style="text-align:left">[]</td><td style="text-align:left">[]</td><td style="text-align:left">[]</td></tr><tr><td style="text-align:left">“AB”</td><td style="text-align:left">[A]</td><td style="text-align:left">[B]</td><td style="text-align:left">[]</td></tr><tr><td style="text-align:left">“ABA”</td><td style="text-align:left">[A,AB]</td><td style="text-align:left">[A, BA]</td><td style="text-align:left">[A]</td></tr><tr><td style="text-align:left">“ABAB”</td><td style="text-align:left">[A, AB, ABA]</td><td style="text-align:left">[B, AB, BAB]</td><td style="text-align:left">[AB]</td></tr><tr><td style="text-align:left">“ABABA”</td><td style="text-align:left">[A, AB, ABA, ABAB]</td><td style="text-align:left">[A, BA, ABA, BABA]</td><td style="text-align:left">[A, ABA]</td></tr><tr><td style="text-align:left">“ABABAB”</td><td style="text-align:left">[A, AB, ABA, ABAB, ABABA]</td><td style="text-align:left">[B, AB, BAB, ABAB, BABAB]</td><td style="text-align:left">[AB, ABAB]</td></tr><tr><td style="text-align:left">“ABABABC”</td><td style="text-align:left">[A, AB, ABA, ABAB, ABABA, ABABAB]</td><td style="text-align:left">[C, BC, ABC, BABC, ABABC, BABABC]</td><td style="text-align:left">[]</td></tr><tr><td style="text-align:left">“ABABABCA”</td><td style="text-align:left">[A, AB, ABA, ABAB, ABABA, ABABAB, ABABABC]</td><td style="text-align:left">[A, CA, BCA, ABCA, BABCA, ABABCA, BABABCA]</td><td style="text-align:left">[A]</td></tr></tbody></table><p>从上表，如果耐心看，完全可以理解前缀和后缀的概念。</p><p>那么“匹配值”又是指什么呢？</p><p><strong>“匹配值”是指前缀和后缀集合，最长共有元素的长度，即交集中最长元素的长度</strong></p><p>那么不难从上表中得出每一位(index)字符对应“匹配值(value)”:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char: | A | B | A | B | A | B | C | A |</span><br><span class="line">index:| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |</span><br><span class="line">value:| 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 |</span><br></pre></td></tr></table></figure><h1 id="匹配值表的使用"><a href="#匹配值表的使用" class="headerlink" title="匹配值表的使用"></a>匹配值表的使用</h1><p>我们可以根据匹配值表来加速查找匹配的过程。  </p><p>下面还是举例说明问题：</p><p>在字符串”BACBABABAABCBABABABCA”(text)中查找上文中的字符串”ABABABCA”(pattern)，<br>下文中对两个字符串的代称为括号之内的单词。</p><p>从 text 第一位开始匹配，第一次匹配成功是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BACBABABAABCBABABABCA</span><br><span class="line"> |</span><br><span class="line"> ABABABCA</span><br></pre></td></tr></table></figure><p>那么开始往后匹配，发现 text 的第二位”C”和 pattern 的第二位”B”不匹配，<br>所以当前部分匹配长度为1(只有一个A)，并且根据上文的匹配值表得到，当前的匹配值为 0。</p><p><code>移动位数 = 已匹配字符长度 - 对应位的匹配值</code></p><p>即 移动位数 = 1 - 0，所以我们继续向后移一位进行匹配。</p><p>再一次匹配成功的情形：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BACBABABAABCBABABABCA</span><br><span class="line">    |||||</span><br><span class="line">    ABABABCA</span><br></pre></td></tr></table></figure><p>此时，text 中的”A”与 pattern 中的 “B” 不匹配，如果不按照算法，肯定是继续后移一位进行匹配。<br>如果根据上述计算公式：</p><p>移动位数 = “ABABA”.length - pattern[4]的匹配值<br>即 5 - 3 = 2</p><p>所以我们可以一次后移两位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BACBABABAABCBABABABCA</span><br><span class="line">    xx|||</span><br><span class="line">      ABABABCA</span><br></pre></td></tr></table></figure><p>又不匹配了，此时应该后移<br> “ABA”.length - pattern[2]的匹配值<br>即 3 - 1 = 2</p><p>继续后移两位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BACBABABAABCBABABABCA</span><br><span class="line">      xx|</span><br><span class="line">        ABABABCA</span><br></pre></td></tr></table></figure><p>继续后移<br>“A”.length - pattern[0]的匹配值<br>即 1 - 0 = 1</p><p>后移一位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BACBABABAABCBABABABCA</span><br><span class="line">        x||</span><br><span class="line">         ABABABCA</span><br></pre></td></tr></table></figure><p>继续后移<br>“AB”.length - pattern[1]的匹配值<br>即 2 - 0 = 2</p><p>后移两位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BACBABABAABCBABABABCA</span><br><span class="line">         xx|</span><br><span class="line">           ABABABCA</span><br></pre></td></tr></table></figure><p><br>第一位都不匹配，我们继续往后移动直到匹配成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BACBABABAABCBABABABCA</span><br><span class="line">             ||||||||</span><br><span class="line">             ABABABCA</span><br></pre></td></tr></table></figure><p>移动几次之后(step=1)，找到了最终匹配结果。</p><p>参考：<br><a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/</a></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>混淆注意事项</title>
      <link href="/2018/04/09/%E6%B7%B7%E6%B7%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2018/04/09/%E6%B7%B7%E6%B7%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<p>当 Debug 版本正常运行，Release 版本出现问题时，第一个想到的可能因素就应该是代码混淆导致的。</p><a id="more"></a><h1 id="打包配置-开启-Debug"><a href="#打包配置-开启-Debug" class="headerlink" title="打包配置 开启 Debug"></a>打包配置 开启 Debug</h1><p>在 build.gradle 中<br>    buildType -&gt; release -&gt; debuggable true</p><h1 id="混淆文件配置注意"><a href="#混淆文件配置注意" class="headerlink" title="混淆文件配置注意"></a>混淆文件配置注意</h1><p>记录为主~</p><h2 id="防止声明混淆"><a href="#防止声明混淆" class="headerlink" title="防止声明混淆"></a>防止声明混淆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes *Annotation*</span><br><span class="line">-keepattributes JavascriptInterface</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 混淆 </tag>
            
            <tag> 打包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 多线程 ：Volatile</title>
      <link href="/2018/04/06/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%EF%BC%9Avolatile/"/>
      <url>/2018/04/06/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%EF%BC%9Avolatile/</url>
      <content type="html"><![CDATA[<p>在多线程并发编程中，锁的运用很常见。synchronized 的几种运用方式，相信大部分 Java 程序员已经很熟悉。而 <strong>volatile 作为轻量级的 synchronized</strong>，不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销。</p><a id="more"></a><p>在现代计算机系统中，由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓存的内存读写了。</p><p>下面是计算机系统中处理器、高速缓存、主内存间的交互关系:</p><p><img src="http://res.cloudinary.com/otway/image/upload/v1525240875/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="计算机系统内存模型"></p><p>基于高速缓存的存储交互很好的解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性。</p><p>下面是Java中线程、主内存、工作内存交互关系:</p><p><img src="http://res.cloudinary.com/otway/image/upload/v1525240877/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="Java 内存模型"></p><h2 id="Volatile-的官方定义"><a href="#Volatile-的官方定义" class="headerlink" title="Volatile 的官方定义"></a>Volatile 的官方定义</h2><p>Java 语言规范第三版中对 volatile 的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了 volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><h2 id="内存不可见的含义"><a href="#内存不可见的含义" class="headerlink" title="内存不可见的含义"></a>内存不可见的含义</h2><p>在 JVM 中，对于多线程应用，如果多个线程同时使用某个没有 volatile 修饰的变量时，每个线程会从主内存拷贝目标变量到当前线程的工作内存中，然后在各自的工作内存进行具体的操作。</p><blockquote><p>可见性的定义：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得到这个修改。</p></blockquote><p>在上面的情景中，不同线程的对主内存变量副本的操作不能够即时的反馈到主内存区，其他线程的工作内存更是无法感知，内存不可见。</p><h2 id="如何保证内存可见"><a href="#如何保证内存可见" class="headerlink" title="如何保证内存可见"></a>如何保证内存可见</h2><p>volatile 如何实现内存可见的呢？<br>在x86处理器下通过工具获取JIT编译器生成的汇编指令：</p><table><thead><tr><th style="text-align:center">语言</th><th style="text-align:left">代码片段</th></tr></thead><tbody><tr><td style="text-align:center">Java</td><td style="text-align:left">instance = new Singleton(); <br> //instance 是 volatile 修饰变量</td></tr><tr><td style="text-align:center">汇编</td><td style="text-align:left">0x01a3de1d: movb $0x0,0x1104800(%esi);<br>0x01a3de24: lock addl $0x0,(%esp);</td></tr></tbody></table><p>有 volatile 变量修饰的共享变量进行写操作的时候会多第二行汇编代码,通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。</p><ul><li>将当前处理器缓存行的数据回写到系统内存。</li><li>这个回写内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。</li></ul><p>也就是说，处理器为了提高处理速度，不直接和内存通讯，而是先将内存数据拷贝到缓存后再操作（同上图）。如果变量声明了 volatile，那么处理器读取操作会直接和内存进行通讯，将变量所在缓存行的数据直接写入系统内存或者直接读取系统内存数据。但是如果其他处理器缓存的数据仍然是旧的数据，那么再执行计算操作就是无意义的。所以这里就存在缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检测自身缓存是否过期，如果检测到自己缓存行对应的数据被修改，那么会将当前处理器缓存行设置为无效状态。当处理器需要该数据进行操作时，会强制从系统内存重新加载到当前处理器缓存中。</p><p><strong>缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。</strong></p><p>具体的专有名词及细节可以看文末的 reference（本节内容摘录自文末的参考文章）.</p><h2 id="保证对-64-位变量读写的原子性"><a href="#保证对-64-位变量读写的原子性" class="headerlink" title="保证对 64 位变量读写的原子性"></a>保证对 64 位变量读写的原子性</h2><p>JVM 可以保证对 32位 数据读写的原子性，但是对于 long 和 double 这样 64位 的数据的读写，会将其分为 高32位 和 低32位 分两次读写。所以对于 long 或 double 的读写并不是原子性的，这样在并发程序中共享 long 或 double 变量就可能会出现问题，于是 JVM 提供了 volatile 关键字来解决这个问题：</p><blockquote><p>使用 volatile 修饰的 long 或 double 变量，JVM 可以保证对其读写的原子性。</p></blockquote><p>但是，此处的 “写” 仅指对 64位 的变量进行直接赋值。</p><h2 id="指令重新排序对-volatile-的影响"><a href="#指令重新排序对-volatile-的影响" class="headerlink" title="指令重新排序对 volatile 的影响"></a>指令重新排序对 volatile 的影响</h2><p>如果一个操作不是原子操作，那么 JVM 便可能会对该操作涉及的指令进行 <strong>重排序</strong>优化。重排序即在不改变程序语义的前提下，通过调整指令的执行顺序，尽可能达到提高运行效率的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a++;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>可能会被重新排序为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">a++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>这样看是没什么影响的。</p><p>但当一个变量是 volatile 修饰时，指令重排序就可能会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numB</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> numC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> numA, <span class="keyword">int</span> numB, <span class="keyword">int</span> numC)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numA  = numA;</span><br><span class="line">        <span class="keyword">this</span>.numB = numB;</span><br><span class="line">        <span class="keyword">this</span>.numC   = numC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 update 方法调用时，numA,numB,numC 的新值都会直接写入系统内存。但是如果重新排序成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> numA, <span class="keyword">int</span> numB, <span class="keyword">int</span> numC)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.numC  = numC;</span><br><span class="line">    <span class="keyword">this</span>.numA   = numA;</span><br><span class="line">    <span class="keyword">this</span>.numB = numB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 numC 变量时，A和B的值仍会写入主内存，但这一次是在A和B的新值写入之前发生的。因此，其他线程无法正确地看到A和B的新值。重新排序的指令的语义已经改变。</p><p>为了解决指令重新排序这个难题，Java volatile 关键字除了提供可见性保证之外，还提供“happens-before”保证：</p><ul><li><p>如果读取/写入其他变量的操作最初就发生在写入 volatile 修饰变量之前，那么指令重新排序时，不允许这个操作被排到被 volatile 修饰的变量写入之后；注意,对于其他变量的操作最初发生在写入 volatile 修饰变量之后的，那么重新排序是仍然有可能排到 volatile 修饰变量写入之前。</p></li><li><p>如果读取/写入其他变量的操作最初就发生在写入 volatile 修饰变量之后，那么指令重新排序时，不允许这个操作被排到被 volatile 修饰的变量写入之前；注意,对于其他变量的操作最初发生在写入 volatile 修饰变量之前的，那么重新排序是仍然有可能排到 volatile 修饰变量写入之后。</p></li></ul><p>上述的“happens-before”保证正在被实施。</p><h2 id="必须保证操作原子性"><a href="#必须保证操作原子性" class="headerlink" title="必须保证操作原子性"></a>必须保证操作原子性</h2><p>对 volatile 修饰的变量操作时，即使每次都是从系统内存读取，都是直接写入系统内存，仍然会存在问题。</p><p>当多个线程同时写入一个 volatile 变量时，例如 <code>i++</code> 操作。对于 <code>i++</code> 这个语句，事实上涉及了 读取－修改－写入 三个操作：</p><ul><li>读取变量到栈中某个位置</li><li>对栈中该位置的值进行自增</li><li>将自增后的值写回到变量对应的存储位置</li></ul><p>volatile 变量只能保证可见性，在不符合以下两条规则的运算场景中，仍需要通过加锁（使用 synchronized 或 java.util.concurrent 中的原子类）来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><h2 id="合适的使用场景"><a href="#合适的使用场景" class="headerlink" title="合适的使用场景"></a>合适的使用场景</h2><p>读取和写入一个 volatile 变量会直接和系统内存通信，对比与处理器缓存通信的消耗要大得多。访问 volatile 变量还防止指令重新排序，这是一种正常的性能增强技术。所以只有在真正需要变量强制可见性时才应该使用。</p><p>具体的几种场景可以参考<a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">正确使用 Volatile 变量</a></p><p>参考资料：</p><ol><li><a href="http://www.infoq.com/cn/articles/ftf-java-volatile" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/ftf-java-volatile</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-jtp06197.html</a></li><li><a href="http://tutorials.jenkov.com/java-concurrency/volatile.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-concurrency/volatile.html</a></li><li>深入理解Java虚拟机 - JVM高级特性与最佳实践</li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>腾讯X5内核 WebView 实践总结</title>
      <link href="/2018/02/22/%E8%85%BE%E8%AE%AFX5%E5%86%85%E6%A0%B8-WebView-%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
      <url>/2018/02/22/%E8%85%BE%E8%AE%AFX5%E5%86%85%E6%A0%B8-WebView-%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>本篇文章是基于 腾讯X5内核 WebView 实践的总结篇，较上篇文章更为完整，具体。</p><a id="more"></a><h1 id="onPageFinished-回调时机"><a href="#onPageFinished-回调时机" class="headerlink" title="onPageFinished() 回调时机"></a>onPageFinished() 回调时机</h1><p>通过 <code>WebView</code> 的回调函数，分析 <code>onPageFinished()</code> 回调时机</p><p>加载某个网址的Android端回调监测如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shouldOverrideUrlLoading   time: 1519274808392</span><br><span class="line"></span><br><span class="line">onPageStarted: time: 1519274808561 // 169ms</span><br><span class="line"></span><br><span class="line">onPageFinished   time: 1519274809735 // 1174ms</span><br><span class="line">onReadableCallback: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">shouldOverrideUrlLoading   time: 1519274811067 --url :shanbay.native.app://document/ready</span><br><span class="line">onReadableCallback: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">onPageFinished   time: 1519274817879 // 9318ms</span><br><span class="line">onReadableCallback: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>据上数据分析：<br>第一次<code>onPageFinished()</code>回调触发是在 1174ms (较<code>onPageStarted()</code>方法)<br>第二次<code>onPageFinished()</code>回调触发是在 9318ms</p><p>通过 <code>chrome://inspect</code>监测的资源加载时序<br><img src="http://res.cloudinary.com/otway/image/upload/v1519276814/inspect_small.png" alt="chrome://inspect"></p><p><strong>Network</strong> 面板突出显示两种事件：<code>DOMContentLoaded</code> 和 <code>load</code></p><p>解析页面的初始标记时会触发 <code>DOMContentLoaded</code>。 此事件将在<strong>Network</strong> 面板上的两个地方显示：</p><ol><li><strong>Overview</strong> 窗格中的蓝色竖线表示事件。</li><li>在 <strong>Summary</strong> 窗格中，您可以看到事件的确切时间。</li></ol><p>页面完全加载时将触发 load。此事件显示在三个地方：</p><ol><li><strong>Overview</strong> 窗格中的红色竖线表示事件。</li><li><strong>Requests Table</strong> 中的红色竖线也表示事件。</li><li>在 Summary 窗格中，您可以看到事件的确切时间。</li></ol><p>分析上图：</p><ol><li><code>DOMContentLoaded</code> 和 <code>load</code> 事件触发时机与<code>Android</code>端的回调触发时机不一致。</li><li>第一次<code>onPageFinished()</code>方法的调用和 <code>document</code> 类型文件加载完成时间相近，且经过多次测试是在该文件加载完成后调用。</li><li>第二次<code>onPageFinished()</code>方法回调时间和<code>load</code>时间相近。</li></ol><p>初步总结：</p><ol><li>第一次<code>onPageFinished()</code>方法是在<code>document</code>类型文件加载完成后调用的。</li><li>第二次<code>onPageFinished()</code>方法是在<code>load</code>完成时回调。</li><li>通过仔细查看<code>shouldOverrideUrlLoading</code>和<code>onPageStarted</code>方法时间差以及 图中 <strong>Overview</strong> 栏，会发现加载网页不是第一时间去请求数据的。所以 <code>onPageStarted()</code>方法较触发是有一定的延迟时间。</li></ol><h1 id="ready-替换-onPageFinished-实现"><a href="#ready-替换-onPageFinished-实现" class="headerlink" title="ready 替换 onPageFinished 实现"></a>ready 替换 onPageFinished 实现</h1><p>据上分析的结果我们会发现，<code>onPageFinished()</code>方法会调用多次，所以，如果我们将业务逻辑放到该方法中执行，如果不做控制，势必会出现一些问题。当然，由于网页类型的多样性，即使做了控制，依然会在特定的页面出现问题。</p><p><strong>那么我们如何摆脱对<code>onPageFinished()</code>的依赖呢？</strong></p><p>网页的加载状况，前端肯定会有生命周期的感知，那么我们为什么不依赖前端的通知来触发<code>Native</code>逻辑呢？</p><p>通过上述的思考，<code>Native</code>的事件触发完全交给前端去主动调取，而不是通过不靠谱的<code>WebView</code>回调。在前端的<code>$.ready()</code>方法中去通知移动端开始执行业务逻辑。</p><p><strong>并且这种方式在时序性能方面有很大提升，比第二次<code>onPageFinished()</code>触发时机早很多（在较为复杂的页面相差更大）</strong></p><h1 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h1><p>上面我们通过 <code>ready()</code> 的主动通知，实现了 <code>onPageFinished()</code> 方法中业务逻辑的优化。</p><p>但是，在单页应用的网页中，<code>$.ready()</code> 只在主页面渲染完成时触发一次，在子页面并不会触发，而且，<code>WebView</code> 的 <code>shouldOverrideUrlLoading()</code> 及 <code>onPageStarted()</code> 方法都不会回调。在一些单应用网页会触发 <code>onPageFinished()</code> 方法，它去请求了新的资源，所以我们感知到了回调。而个别网页并没有去请求新的资源，直接对资源进行了替换，这种情况，我们就感知不到 <code>onPageFinished()</code> 的回调。</p><p>当然，如果开发自己的页面就不存在这些多情况的处理，可以协商解决方案。</p><p>本文的主要实现是基于第三方网页做的功能扩展，所以需要考虑这些兼容性问题。</p><p>给出不成熟的参考方案：</p><ol><li>前端 <code>url</code> 变化监听，通知移动端页面变化。</li><li>在 <code>onPageFinished()</code> 方法中再去做一个保底操作，损失一部分性能换取用户的响应速度。</li></ol><h1 id="Js-注入时机以及时序控制"><a href="#Js-注入时机以及时序控制" class="headerlink" title="Js 注入时机以及时序控制"></a>Js 注入时机以及时序控制</h1><p>网络上的普遍做法是在 <code>onPageFinished()</code> 中注入 <code>Js</code> 脚本。</p><p>这种做法存在一些问题：</p><ul><li><p>可能会注入多次。</p></li><li><p>onPageFinished()第二次调用时机很迟，在复杂的页面性能损失很大。</p></li><li><p>如果注入太多，会影响页面的体验。</p></li></ul><p>由于项目注入的脚本行数达到 1W+，所以我们需要对时序做一些优化。保证调用时我们已经完成了注入。</p><p>这里我们主要注入生成一个 <code>script</code> 标签。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">webView.loadUrl(<span class="string">"javascript:(function() &#123;"</span> +</span><br><span class="line">        <span class="string">"var scriptElement = document.getElementById('readability-script');"</span> +</span><br><span class="line">        <span class="string">"var parent = document.getElementsByTagName('body').item(0);"</span> +</span><br><span class="line">        <span class="string">"if(parent &amp;&amp; !scriptElement) &#123;"</span> +</span><br><span class="line">        <span class="string">"var script = document.createElement('script');"</span> +</span><br><span class="line">        <span class="string">"script.type = 'text/javascript';"</span> +</span><br><span class="line">        <span class="string">"script.id = 'readability-script';"</span> +</span><br><span class="line">         <span class="comment">// Tell the browser to BASE64-decode the string into your script !!!</span></span><br><span class="line">        <span class="string">"script.innerHTML = window.atob('"</span> + mAssetsScript + <span class="string">"');"</span> +</span><br><span class="line">        <span class="string">"parent.appendChild(script);&#125;"</span> +</span><br><span class="line">        <span class="string">"&#125;)()"</span>);</span><br></pre></td></tr></table></figure><p>通过控制标签的唯一性来防止注入多次； 在页面初始化前完成本地 js 脚本的文件读取；不断尝试注入直到可以注入为止。</p><p>在 <code>onProgressChanged()</code> 回调中，不断的尝试读取节点注入脚本。</p><p>通过最开始对 <code>onPageFinished()</code> 的分析。是否可以尝试在第一次回调时开始注入脚本。但是，不能保证每个网页都会回调两次<code>onPageFinished()</code>。</p><blockquote><p>通常情况下，CSS不会阻塞HTML的解析，但如果CSS后面有JS，则会阻塞JS的执行直到CSS加载完成（即便JS是内联的脚本），从而间接阻塞HTML的解析。</p></blockquote><h1 id="资源加载回调"><a href="#资源加载回调" class="headerlink" title="资源加载回调"></a>资源加载回调</h1><p>在研究<code>WebView</code>加载时序时发现了这个资源加载的回调<code>onLoadResource()</code>。这里简单介绍下，针对这个回调，可以做的事情很多。</p><p>在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> WebViewClient()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLoadResource</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>可以实现预加载及手动缓存的功能。优化用户体验并且减少多次访问造成的流量浪费。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p><a href="https://github.com/riskers/blog/issues/11">打造最舒适的 WebView 调试环境</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>腾讯X5内核 WebView 实践篇</title>
      <link href="/2018/02/03/%E8%85%BE%E8%AE%AFX5%E5%86%85%E6%A0%B8-Webview-%E5%AE%9E%E8%B7%B5%E7%AF%87/"/>
      <url>/2018/02/03/%E8%85%BE%E8%AE%AFX5%E5%86%85%E6%A0%B8-Webview-%E5%AE%9E%E8%B7%B5%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>基于腾讯X5内核的<code>WebView</code>开发：<br>1.<code>onPageFinished</code><br>2.<code>onProgressChanged()</code><br>3.合适的时机获取页面元素<br><a id="more"></a></p><h1 id="onPageFinished-踩坑"><a href="#onPageFinished-踩坑" class="headerlink" title="onPageFinished() 踩坑"></a>onPageFinished() 踩坑</h1><p>业务需求是在 <code>html</code> 中注入 <code>js</code>脚本实现阅读模式切换功能。但是基于开源项目 <a href="https://github.com/mozilla/readability">mozilla/readability</a> 开发，项目脚本过长，如果不能选定合适的时机注入，那么势必会影响用户交互。</p><p>在实现需求阶段，实现方式是在 <code>onPageFinished()</code> 注入 <code>js</code>。注入代码完成之后，在页面 <code>ready()</code> 状态中主动去通知客户端当前页面内容加载完成，并且是否可以切换阅读模式。根据前端的状态返回来确定客户端的表现。当然，这个过程是缓慢的，所以不建议直接加载阅读模式的<code>html</code> 。</p><p>注入代码留存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectScriptFile</span><span class="params">(X5WebView webView, String scriptFile)</span> </span>&#123;</span><br><span class="line">        InputStream input;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input = getActivity().getAssets().open(scriptFile);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[input.available()];</span><br><span class="line">            input.read(buffer);</span><br><span class="line">            input.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// String-ify the script byte-array using BASE64 encoding !!!</span></span><br><span class="line">            String encoded = Base64.encodeToString(buffer, Base64.NO_WRAP);</span><br><span class="line">            webView.loadUrl(<span class="string">"javascript:(function() &#123;"</span> +</span><br><span class="line">                    <span class="string">"var scriptElement = document.getElementById('readability-script');"</span> +</span><br><span class="line">                    <span class="comment">//"alert(scriptElement);" +</span></span><br><span class="line">                    <span class="string">"if(!scriptElement) &#123;"</span> +</span><br><span class="line">                    <span class="string">"var parent = document.getElementsByTagName('head').item(0);"</span> +</span><br><span class="line">                    <span class="string">"var script = document.createElement('script');"</span> +</span><br><span class="line">                    <span class="string">"script.type = 'text/javascript';"</span> +</span><br><span class="line"><span class="comment">//                    "script.async = 'true';" +</span></span><br><span class="line">                    <span class="string">"script.id = 'readability-script';"</span> +</span><br><span class="line">                    <span class="comment">// Tell the browser to BASE64-decode the string into your script !!!</span></span><br><span class="line">                    <span class="string">"script.innerHTML = window.atob('"</span> + encoded + <span class="string">"');"</span> +</span><br><span class="line">                    <span class="string">"parent.appendChild(script);&#125;"</span> +</span><br><span class="line">                    <span class="string">"&#125;)()"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在功能完成之后，我们发现，有的网页出现<em>解析代码运行之后通知客户端是可读的，但是我们并不能获取到展示的文本信息。导致切换阅读模式出现空白页面的情况。</em></p><p>这个Bug目前还没有解决，规避方案是当前页面的检测结果为可切换阅读模式页面并且可阅读文本不为空时，我们才会通知客户端该页面支持阅读模式的状态。我们目前选择了规避。</p><p>在页面调试时发现，上述的<code>script</code>标签内容导入了两次，虽然能够正常运行，但是无疑是增加了<code>WebView</code>消耗。</p><p>经过排查发现，在新网页开启时，会立即调用<code>onPageStarted()</code>和<code>onPageFinished()</code>方法，这个时候会第一次注入<code>js</code>,当页面完全加载完，<code>WebView</code>还是会回调一次<code>onPageFinished()</code>方法。那么这就是第二次的注入时机。<br>上面的分析合情合理，但是真实原因并不是这个，因为我们发现在第一次<code>onPageFinished()</code>调用的时候，我们在注入<code>js</code>之后会去主动调用注入的一个方法，通过 <a href="chrome://inspect" target="_blank" rel="noopener">chrome://inspect</a> 调试发现，这个时候调用的方法是<code>Undefined</code>状态，所以说我们的注入是失败的。那么也就说明一个猜测，第一次回调<code>onPageFinished()</code>时，网页并没有完成<code>html</code>基本的格式加载。为什么在没有完成加载最基础的标签时，我们会收到<code>onPageFinished()</code>回调呢，这简直就是一个大坑，这个问题还没有深入研究，待后续再说吧。</p><p>排除了上述这个原因，那么为什么会出现<code>js</code>导入多次的情况呢？</p><p>由于本人并不了解前端开发，所以出现这个问题才知晓了<strong>单页面应用</strong>的概念，具体的可以自行了解<a href="https://baike.baidu.com/item/SPA/17536313" target="_blank" rel="noopener">单页应用程序</a>。</p><p>在单页面应用中，页面跳转中 <code>&lt;header/&gt;</code> 标签内容是一直存在的。在主页注入<code>&lt;script/&gt;</code>标签之后，在后续的<code>onPageFinished()</code>方法中重复导入。就会造成注入冗余的情况。</p><p>终于找到原因所在，那么上述的注入代码中，修改了<code>js</code>部分的代码，先去确定标签不存在再去注入。</p><blockquote><p>总结：<br>单页面应用在跳转时只会刷新<code>&lt;body/&gt;</code>内的信息，当然其他标签如果有更新也会变化，暂不考虑。而<code>&lt;header/&gt;</code>中注&gt;入<code>js</code>的动作执行了两次，所以导致了<code>&lt;script/&gt;</code>标签冗余。</p></blockquote><p><strong>这里还有个坑，在单页应用跳转时除了第一次加载外框页面会回调<code>onPageStarted()</code>,之后的内部页面跳转是没有这个回调的。</strong></p><h1 id="onProgressChanged"><a href="#onProgressChanged" class="headerlink" title="onProgressChanged()"></a>onProgressChanged()</h1><p><code>WebView</code> 可以通过设置 <code>WebChromeClient</code> 来监听页面资源的加载情况，本文主要用<code>onProgressChanged()</code>方法。</p><p>在上面已经说过，需要注入的<code>js</code>过长，如果放在页面加载完成再去注入，是否很不合理。所以我们希望可以在页面加载过程中，去异步的注入。</p><p>最理想的状态是页面基本<code>html</code>加载完成之后，给客户端一个状态通知，然后这个时机去异步注入（想想罢了，不知道前端技术人员是否能够感知到这个状态）。</p><p>采取了大众方案，在<code>onProgressChanged(WebView webView, int newProgress)</code>回调的30%去注入。当然具体的进度值还需要自己去测试。</p><p>通过<code>logcat</code>你会发现，这里的进度显示也很诡异。</p><p>逼不得已，添加了一个<code>flag</code>来控制，在第一次导入开始时关闭，在<code>onPageStarted()</code>中打开。</p><h1 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h1><p>既然<code>WebView</code>的回调方法这么不靠谱，那么我们就不能将核心功能依赖这两个不靠谱的方法。</p><p>由于阅读模式的检测是需要解析页面元素的，那么前端小伙伴是否能够在能够解析并解析完成之后将结果主动地下发到客户端呢？</p><p>前端我只是了解了一个<code>ready()</code>的方法，是可以监听到页面加载完成的，前端发送一个跳转给客户端，客户端需要通过<code>shouldOverrideUrlLoading(WebView webView, String url)</code>方法主动去拦截前端的跳转，然后根据需求，可以去完成对应的具体功能。</p><p>这部分还在研究，看看前端是否有更加精准的方式来通知客户端。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RecyclerView &amp; NestedScrollView 嵌套收缩动画解决方案</title>
      <link href="/2018/01/27/RecyclerView-NestedScrollView-%E5%B5%8C%E5%A5%97%E6%94%B6%E7%BC%A9%E5%8A%A8%E7%94%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/01/27/RecyclerView-NestedScrollView-%E5%B5%8C%E5%A5%97%E6%94%B6%E7%BC%A9%E5%8A%A8%E7%94%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>在复杂的业务场景中，会利用到 NestedScrollView 嵌套好几个固定的布局来展示内容。<br>在固定的布局中可能存在竖向的列表，并且要求列表完全展开。针对列表中的 Item 还需要赋予位置移动动画，整个列表收缩动画及展开动画。</p><a id="more"></a><h1 id="情景说明"><a href="#情景说明" class="headerlink" title="情景说明"></a>情景说明</h1><p>本文针对该场景采取的是嵌套实现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/nested_scroll_view"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:fillViewport</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:id</span>=<span class="string">"@+id/container"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">android:id</span>=<span class="string">"@+id/recycler_view"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">android.support.v7.widget.RecyclerView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:background</span>=<span class="string">"@color/colorAccent"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">android.support.v4.widget.NestedScrollView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的布局中，RecyclerView中是一个列表数据的展示，其中包含 位置移动，收缩，展开等操作。（PS：上述层级较多，只是为了测试层级对RecyclerView的影响，毕竟复杂场景不会只有一个RecyclerView</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val list = ArrayList&lt;Int&gt;()</span><br><span class="line">list += <span class="number">1.</span><span class="number">.20</span></span><br><span class="line">recycler_view.layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">adapter = Adapter&lt;Int&gt;(list)</span><br><span class="line">recycler_view.adapter = adapter</span><br><span class="line">recycler_view.itemAnimator = DefaultItemAnimator()</span><br><span class="line">recycler_view.itemAnimator.addDuration = <span class="number">1000</span></span><br><span class="line">recycler_view.itemAnimator.removeDuration = <span class="number">1000</span></span><br><span class="line">adapter!!.expand()</span><br></pre></td></tr></table></figure><p>这里我们将动画的时长设置很长，便于观察。其中 Adapter 增加了收缩和展开的方法。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">var</span> maxCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">override fun getItemCount(): Int &#123;</span><br><span class="line">    <span class="keyword">return</span> minOf(dataList.size, maxCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun expand() &#123;</span><br><span class="line">    val count = itemCount    <span class="comment">//  同  getItemCount()</span></span><br><span class="line">    maxCount = Int.MAX_VALUE</span><br><span class="line">    notifyItemRangeInserted(count, itemCount - count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun collapse() &#123;</span><br><span class="line">    val count = itemCount</span><br><span class="line">    maxCount = <span class="number">1</span></span><br><span class="line">    notifyItemRangeRemoved(<span class="number">1</span>, count - itemCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的配置之后，我们发现。在展开动画开启时，RecyclerView 会伸缩到合适的高度以容纳 所有的 Item（这里设置了 <code>android:fillViewport=&quot;true&quot;</code> 的属性），然后我们才会看到默认的 add Item 的动画。但是，当我们收缩列表的时候，并没有观察到动画，给人的感觉是 直接 调用了 <code>notifyDataSetChanged()</code> 的方法。下面我们追踪一下源码来看看为什么会出现这种问题。</p><p>首先是  <code>notifyItemRangeRemoved()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notifyItemRangeRemoved</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;</span><br><span class="line">    mObservable.notifyItemRangeRemoved(positionStart, itemCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据该条代码进行追踪到最终实现的部分，在 <code>RecyclerViewDataObserver</code> 的实现中，我们找到了具体的实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemRangeRemoved</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;</span><br><span class="line">        assertNotInLayoutOrScroll(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) &#123;</span><br><span class="line">            triggerUpdateProcessor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">triggerUpdateProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) &#123;</span><br><span class="line">            ViewCompat.postOnAnimation(RecyclerView.<span class="keyword">this</span>, mUpdateChildViewsRunnable);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mAdapterUpdateDuringMeasure = <span class="keyword">true</span>;</span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>mHasFixedSize</code> 字段的控制是关键所在，默认是false，所以直接进行了 <code>requestLayout()</code> 的操作，导致RecyclerView的高度直接变化到最小。</p><h1 id="个人解决方案"><a href="#个人解决方案" class="headerlink" title="个人解决方案"></a>个人解决方案</h1><ul><li>如果列表的初始状态为完全展开状态。可以通过测量第一个Item高度，以及总高度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">recycler_view.post &#123;</span><br><span class="line">    val viewFirst = recycler_view.layoutManager.findViewByPosition(<span class="number">0</span>)</span><br><span class="line">    firstItemHeight = viewFirst!!.height</span><br><span class="line">    totalHeight = recycler_view.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 adapter.collapse()或者 expand()的时候 调用 下面的方法。</span></span><br><span class="line">height(recycler_view, totalHeight.toFloat(), firstItemHeight.toFloat(), <span class="number">1000</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>只需要在收缩时 调用  height  的动画即可，展开也可以调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun height(view: View, <span class="attr">from</span>: Float, <span class="attr">to</span>: Float, <span class="attr">duration</span>: Int, <span class="attr">animatorListener</span>: Animator.AnimatorListener?): ValueAnimator &#123;</span><br><span class="line">    val animator = ValueAnimator.ofFloat(<span class="keyword">from</span>, to)</span><br><span class="line">    animator.duration = duration.toLong()</span><br><span class="line">    <span class="keyword">if</span> (animatorListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        animator.addListener(animatorListener)</span><br><span class="line">    &#125;</span><br><span class="line">    animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">        <span class="keyword">if</span> (view.layoutParams != <span class="literal">null</span>) &#123;</span><br><span class="line">            val lp = view.layoutParams</span><br><span class="line">            val aFloat = animation.animatedValue <span class="keyword">as</span> Float</span><br><span class="line">            lp.height = aFloat.toInt()</span><br><span class="line">            view.layoutParams = lp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    animator.start()</span><br><span class="line">    <span class="keyword">return</span> animator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过设置  <code>mHasFixedSize</code> 属性 来达到目的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (iem.itemId == R.id.collapse) &#123;</span><br><span class="line">    recycler_view.setHasFixedSize(<span class="keyword">true</span>)</span><br><span class="line">    it.collapse()</span><br><span class="line">    recycler_view.postDelayed(&#123;</span><br><span class="line">        recycler_view.setHasFixedSize(<span class="keyword">false</span>)</span><br><span class="line">        recycler_view.requestLayout()</span><br><span class="line">    &#125;, recycler_view.itemAnimator.addDuration)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    recycler_view.setHasFixedSize(<span class="keyword">false</span>)</span><br><span class="line">    it.expand()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Menu</title>
      <link href="/2017/12/10/Android-Menu/"/>
      <url>/2017/12/10/Android-Menu/</url>
      <content type="html"><![CDATA[<p>在使用 <code>Android</code> 版微信时发现，微信移除了侧滑操作，改为弹窗实现。个人对该方式很喜欢，所以对 <code>Menu</code> 的内容进行了整理。</p><a id="more"></a><h1 id="选项菜单-OptionMenu"><a href="#选项菜单-OptionMenu" class="headerlink" title="选项菜单 OptionMenu"></a>选项菜单 <code>OptionMenu</code></h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@[+][package:]id/resource_name"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:title</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:titleCondensed</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:icon</span>=<span class="string">"@[package:]drawable/drawable_resource_name"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:onClick</span>=<span class="string">"method name"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:showAsAction</span>=<span class="string">[</span>"<span class="attr">ifRoom</span>" | "<span class="attr">never</span>" | "<span class="attr">withText</span>" | "<span class="attr">always</span>" | "<span class="attr">collapseActionView</span>"]</span></span><br><span class="line"><span class="tag">          <span class="attr">android:actionLayout</span>=<span class="string">"@[package:]layout/layout_resource_name"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:actionViewClass</span>=<span class="string">"class name"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:actionProviderClass</span>=<span class="string">"class name"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:alphabeticShortcut</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:alphabeticModifiers</span>=<span class="string">[</span>"<span class="attr">META</span>" | "<span class="attr">CTRL</span>" | "<span class="attr">ALT</span>" | "<span class="attr">SHIFT</span>" | "<span class="attr">SYM</span>" | "<span class="attr">FUNCTION</span>"]</span></span><br><span class="line"><span class="tag">          <span class="attr">android:numericShortcut</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:numericModifiers</span>=<span class="string">[</span>"<span class="attr">META</span>" | "<span class="attr">CTRL</span>" | "<span class="attr">ALT</span>" | "<span class="attr">SHIFT</span>" | "<span class="attr">SYM</span>" | "<span class="attr">FUNCTION</span>"]</span></span><br><span class="line"><span class="tag">          <span class="attr">android:checkable</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">          <span class="attr">android:visible</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">          <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">          <span class="attr">android:menuCategory</span>=<span class="string">[</span>"<span class="attr">container</span>" | "<span class="attr">system</span>" | "<span class="attr">secondary</span>" | "<span class="attr">alternative</span>"]</span></span><br><span class="line"><span class="tag">          <span class="attr">android:orderInCategory</span>=<span class="string">"integer"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:id</span>=<span class="string">"@[+][package:]id/resource name"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:checkableBehavior</span>=<span class="string">[</span>"<span class="attr">none</span>" | "<span class="attr">all</span>" | "<span class="attr">single</span>"]</span></span><br><span class="line"><span class="tag">           <span class="attr">android:visible</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">           <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">           <span class="attr">android:menuCategory</span>=<span class="string">[</span>"<span class="attr">container</span>" | "<span class="attr">system</span>" | "<span class="attr">secondary</span>" | "<span class="attr">alternative</span>"]</span></span><br><span class="line"><span class="tag">           <span class="attr">android:orderInCategory</span>=<span class="string">"integer"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">menu</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">item</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>android:showAsAction</code></p><ul><li><code>ifRoom</code>: Only place this item in the app bar if there is room for it</li><li><code>never</code>: overflow menu</li><li><code>withText</code>: only text  <code>android:title</code></li><li><code>always</code>: on the bar</li><li><code>collapseActionView</code>: <code>android:actionLayout</code> or <code>android:actionViewClass</code></li></ul></li><li><p><code>android:actionViewClass</code></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/action_search"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"@string/action_search"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_search"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">"ifRoom|collapseActionView"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:actionViewClass</span>=<span class="string">"android.support.v7.widget.SearchView"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>通过 <code>setOnActionExpandListener()</code> 监听展开收缩事件</p><ul><li><p><code>android:actionViewLayout</code><br> 引入布局用于操作窗口，效果类似于<code>android:actionViewClass</code></p></li><li><p><code>android:actionProviderClass</code></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/action_share"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"share"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">"always"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:actionProviderClass</span>=<span class="string">"android.support.v7.widget.ShareActionProvider"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p>显示布局及可以监听相关事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">    getMenuInflater().inflate(R.menu.menu_main, menu);</span><br><span class="line">    MenuItem shareItem = menu.findItem(R.id.action_share);</span><br><span class="line">    <span class="keyword">if</span> (searchItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mShareActionProvider = (ShareActionProvider) MenuItemCompat.getActionProvider(shareItem);</span><br><span class="line">        <span class="keyword">if</span> (!setShareIntent())&#123;</span><br><span class="line">            menu.removeItem(R.id.action_share);</span><br><span class="line">            <span class="comment">//没有第三方可以分享，可以自定义</span></span><br><span class="line">            <span class="comment">//如果一个应用程序需要接受Share Intent发送的共享数据，</span></span><br><span class="line">            <span class="comment">// 那么需要在该应用程序的Manifest.xml文件中定义&lt;intent-filter/&gt;元素 </span></span><br><span class="line">                <span class="comment">//android.intent.action.SEND，</span></span><br><span class="line">            <span class="comment">// 指明应用组件想要接受的intent</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateOptionsMenu(menu);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call to update the share intent</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setShareIntent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mShareActionProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Intent shareIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">        shareIntent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">        shareIntent.putExtra(Intent.EXTRA_TEXT, <span class="string">"share content"</span>);<span class="comment">//EXTRA_STREAM</span></span><br><span class="line"></span><br><span class="line">        PackageManager pm = getPackageManager();</span><br><span class="line">        <span class="comment">//检查手机上是否存在可以处理这个动作的应用</span></span><br><span class="line">        List&lt;ResolveInfo&gt; infoList = pm.queryIntentActivities(shareIntent, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!infoList.isEmpty()) &#123;</span><br><span class="line">            mShareActionProvider.setShareIntent(shareIntent);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种会记录偏好，可通过<code>setShareHistoryFileName()</code>设置记录的xml文件名</p><p>设置<code>setOnShareTargetSelectedListener</code>监听条目点击事件</p><blockquote><p>可继承<code>support</code>包下<code>ActionProvider</code>自定义实现<br><code>android.support.design.R.dimen.abc_action_bar_default_height_material</code></p></blockquote><h2 id="关于overflow-menu在高版本不显示icon"><a href="#关于overflow-menu在高版本不显示icon" class="headerlink" title="关于overflow menu在高版本不显示icon"></a>关于overflow menu在高版本不显示icon</h2><p>安卓4.0之前会显示icon，高版本中不会显示，可以通过反射去设置icon的显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIconEnable</span><span class="params">(Menu menu, <span class="keyword">boolean</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (menu != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = menu.getClass();</span><br><span class="line">            <span class="keyword">if</span> (clazz.getSimpleName().equals(<span class="string">"MenuBuilder"</span>)) &#123;</span><br><span class="line">                Method m = clazz.getDeclaredMethod(<span class="string">"setOptionalIconsVisible"</span>, Boolean.TYPE);</span><br><span class="line">                m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//MenuBuilder实现Menu接口，创建菜单时，传进来的menu其实就是MenuBuilder对象                </span></span><br><span class="line">                m.invoke(menu, enable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  android 4.0以后使用AppCompatActivity必须在该方法中调用setIconEnable（），</span></span><br><span class="line"><span class="comment">    *  隐藏的menuitem的icon才会显示</span></span><br><span class="line"><span class="comment">    *  android 4.0以后其他的activity可以再onPrepreOptionMenu()中调用</span></span><br><span class="line"><span class="comment">    *  android 4.0以前可以正常显示overflow中的menuitem的icon</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> menu</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onPrepareOptionsPanel</span><span class="params">(View view, Menu menu)</span> </span>&#123;</span><br><span class="line">    setIconEnable(menu, <span class="keyword">true</span>);<span class="comment">//让在overflow中的menuitem的icon显示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onPrepareOptionsPanel(view, menu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手机实体菜单按键导致actionbar上的三个点图标不显示"><a href="#手机实体菜单按键导致actionbar上的三个点图标不显示" class="headerlink" title="手机实体菜单按键导致actionbar上的三个点图标不显示"></a>手机实体菜单按键导致actionbar上的三个点图标不显示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过反射，设置实体menu键可用与否</span></span><br><span class="line"><span class="comment">    * 该方法在onCreate（）中调用</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> enable  false:实体键不可用，会在actionbar上显示小点 </span></span><br><span class="line"><span class="comment">    *                true：可用，点击menu实体键才会显示menuitem</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasPermanentMenuKey</span><span class="params">(<span class="keyword">boolean</span> enable)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ViewConfiguration mconfig = ViewConfiguration.get(<span class="keyword">this</span>);</span><br><span class="line">        Field menuKeyField = ViewConfiguration.class.getDeclaredField(<span class="string">"sHasPermanentMenuKey"</span>);</span><br><span class="line">        <span class="keyword">if</span>(menuKeyField != <span class="keyword">null</span>) &#123;</span><br><span class="line">            menuKeyField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            menuKeyField.setBoolean(mconfig, enable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可以通过自定义toolbar中布局实现理想效果"><a href="#可以通过自定义toolbar中布局实现理想效果" class="headerlink" title="可以通过自定义toolbar中布局实现理想效果"></a>可以通过自定义toolbar中布局实现理想效果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ActionBar actionBar = getSupportActionBar();</span><br><span class="line"><span class="comment">//设置自定义actionbar的view</span></span><br><span class="line">actionBar.setCustomView(R.layout.action_bar_layout);</span><br><span class="line"><span class="comment">//设置展示的options为DISPLAY_SHOW_CUSTOM</span></span><br><span class="line">actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);</span><br><span class="line"><span class="comment">//设置showCustom为true</span></span><br><span class="line">actionBar.setDisplayShowCustomEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h1 id="上下文菜单-ContextMenu"><a href="#上下文菜单-ContextMenu" class="headerlink" title="上下文菜单  ContextMenu"></a>上下文菜单  ContextMenu</h1><h2 id="浮动上下文菜单"><a href="#浮动上下文菜单" class="headerlink" title="浮动上下文菜单"></a>浮动上下文菜单</h2><ul><li><code>registerForContextMenu(View view)</code>注册于上下文菜单关联的View</li><li><strong>Activity</strong> 或 <strong>Fragment</strong>实现 <code>registerForContextMenu()</code>，当关联的View收到长按事件之后，会响应该方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreateContextMenu</span><span class="params">(ContextMenu menu, View v,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ContextMenuInfo menuInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreateContextMenu(menu, v, menuInfo);</span><br><span class="line">    MenuInflater inflater = getMenuInflater();</span><br><span class="line">    inflater.inflate(R.menu.context_menu, menu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>事件监听</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onContextItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();</span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onContextItemSelected(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为单个视图启用上下文操作模式"><a href="#为单个视图启用上下文操作模式" class="headerlink" title="为单个视图启用上下文操作模式"></a>为单个视图启用上下文操作模式</h2><ul><li>实现 ActionMode.Callback 接口。在其回调方法中，您既可以为上下文操作栏指定操作，又可以响应操作项目的点击事件，还可以处理操作模式的其他生命周期事件</li><li>当需要显示操作栏时，调用<code>activity</code>的<code>startActionMode()</code>方法</li></ul><h2 id="弹出菜单-PopupMenu"><a href="#弹出菜单-PopupMenu" class="headerlink" title="弹出菜单 PopupMenu"></a>弹出菜单 PopupMenu</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPopup</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    PopupMenu popup = <span class="keyword">new</span> PopupMenu(<span class="keyword">this</span>, v);</span><br><span class="line">    MenuInflater inflater = popup.getMenuInflater();</span><br><span class="line">    inflater.inflate(R.menu.actions, popup.getMenu());</span><br><span class="line">    popup.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>setOnMenuItemclickListener()</code>设置监听</p><h2 id="基于-Intent-的菜单项"><a href="#基于-Intent-的菜单项" class="headerlink" title="基于 Intent 的菜单项"></a>基于 Intent 的菜单项</h2><p>通过intent_filter定义删选规则  <code>CATEGORY_ALTERNATIVE</code> 和 <code>CATEGORY_SELECTED_ALTERNATIVE</code></p><p>调用<code>Menu.addIntentOptions()</code>来添加应用列表</p><h2 id="ListPopupMenu"><a href="#ListPopupMenu" class="headerlink" title="ListPopupMenu"></a>ListPopupMenu</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ListPopupWindow popup = <span class="keyword">new</span> ListPopupWindow(mContext);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"不喜欢"</span>);</span><br><span class="line">list.add(<span class="string">"举报"</span>);</span><br><span class="line">popup.setBackgroundDrawable(<span class="keyword">new</span> ColorDrawable(Color.WHITE));</span><br><span class="line">popup.setAdapter(<span class="keyword">new</span> ArrayAdapter&lt;&gt;(mContext, R.layout.biz_elevator_layout_note_popup_item, list));</span><br><span class="line">popup.setWidth( mContext.getResources().getDimensionPixelSize(R.dimen.width40));</span><br><span class="line">popup.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">popup.setAnchorView(mUserLayout);</span><br><span class="line">popup.setModal(<span class="keyword">true</span>);</span><br><span class="line">popup.setOnItemClickListener(<span class="keyword">new</span> AdapterView.OnItemClickListener() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        popup.dismiss();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">popup.setHorizontalOffset(-<span class="number">40</span>);</span><br><span class="line">popup.setDropDownGravity(Gravity.END);</span><br><span class="line">popup.show();</span><br></pre></td></tr></table></figure><h2 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> PopupWindow popupWindow = <span class="keyword">new</span> PopupWindow(mContext);</span><br><span class="line">View inflate = LayoutInflater.from(mContext).inflate(R.layout.biz_elevator_layout_note_item_popup, <span class="keyword">null</span>);</span><br><span class="line">View tvDislike = inflate.findViewById(R.id.popup_dislike);</span><br><span class="line">View tvReport = inflate.findViewById(R.id.popup_report);</span><br><span class="line"></span><br><span class="line">tvDislike.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCallback.onDisLikeClicked(v, mPosition);</span><br><span class="line">        &#125;</span><br><span class="line">        popupWindow.dismiss();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">tvReport.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCallback.onReportClicked(v, mPosition);</span><br><span class="line">        &#125;</span><br><span class="line">        popupWindow.dismiss();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">popupWindow.setContentView(inflate);</span><br><span class="line">popupWindow.setWidth(ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">popupWindow.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要设置带阴影的 .9 背景，需要在此处设置，而不是在布局文件中写。</span></span><br><span class="line">Drawable drawableDot9 = getResources().getDrawable(R.drawable.bg_popup_with_shadow);</span><br><span class="line">popupWindow.setBackgroundDrawable(drawableDot9);</span><br><span class="line"><span class="comment">// popupWindow.setBackgroundDrawable(new ColorDrawable(Color.WHITE));</span></span><br><span class="line"><span class="comment">// this setting can intercept the touch event when popupWindow opened</span></span><br><span class="line">popupWindow.setFocusable(<span class="keyword">true</span>);</span><br><span class="line">popupWindow.setTouchable(<span class="keyword">true</span>);</span><br><span class="line">popupWindow.setOutsideTouchable(<span class="keyword">true</span>);</span><br><span class="line">PopupWindowCompat.showAsDropDown(popupWindow, v, -<span class="number">10</span>, <span class="number">10</span>, Gravity.BOTTOM);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> menu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>zsh[Oh My Zsh]</title>
      <link href="/2017/12/10/zsh-Oh-My-Zsh/"/>
      <url>/2017/12/10/zsh-Oh-My-Zsh/</url>
      <content type="html"><![CDATA[<p><code>iTerm2</code> 中对于分支的显示方案并不是很人性化。通过安装 <code>Oh-My-Zsh</code> 对分支控制了然于胸。<br>本篇文章主要介绍 <code>Oh-My-Zsh</code> 的安装以及主题搭配方案。感兴趣的同学可以参照着配置自己喜欢的主题样式</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line"># Backup your existing ~/.zshrc file:  optional</span><br><span class="line">cp ~/.zshrc ~/.zshrc.orig</span><br><span class="line"># Recommend</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br><span class="line"># Change your default shell</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><hr><p>采用的是<a href="https://github.com/bhilburn/powerlevel9k">powerlevel9k</a>主题，色系是<a href="https://github.com/Ch4s3/iTerm2-Neutron">Neutron</a></p><p>以下是安装 powerline 以及解决字体乱码问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pip install --user powerline-status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download fonts and font config.</span></span><br><span class="line">wget https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otf</span><br><span class="line">wget https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux</span></span><br><span class="line">mv PowerlineSymbols.otf ~/.fonts/</span><br><span class="line"><span class="comment"># Update font cache for the path the font was moved to.</span></span><br><span class="line"><span class="built_in">fc</span>-cache -vf ~/.fonts/</span><br><span class="line"><span class="comment"># Install the fontconfig file.</span></span><br><span class="line">mv 10-powerline-symbols.conf ~/.config/fontconfig/conf.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac OS X</span></span><br><span class="line"><span class="comment"># You can click the PowerlineSymbols.otf to install or you can move the file to font dir like:</span></span><br><span class="line">mv PowerlineSymbols.otf /Library/Fonts/</span><br></pre></td></tr></table></figure><p>字体安装完毕之后，需要:</p><blockquote><p>配置色系</p></blockquote><ul><li>Launch iTerm 2. Get the latest version at <a href="http://www.iterm2.com/" target="_blank" rel="noopener">iterm2.com</a></li><li>Type CMD+i (⌘+i)</li><li>Navigate to Colors tab</li><li>Click on Load Presets</li><li>Click on Import</li><li>Save the neutron.itermcolors file</li><li>Click on Load Presets and choose neutron</li></ul><blockquote><p>配置字体</p></blockquote><ul><li>Navigate to Text tab</li><li>Click Change Font</li><li>Search PowerlineSymbols and select to use</li></ul><p>样式配置(在~/.zshrc中添加):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir vcs)</span><br><span class="line">POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status time)</span><br><span class="line">POWERLEVEL9K_TIME_FORMAT=<span class="string">"%D&#123;%H:%M:%S&#125;"</span></span><br><span class="line">POWERLEVEL9K_NODE_VERSION_BACKGROUND=<span class="string">'022'</span></span><br><span class="line">POWERLEVEL9K_SHORTEN_DIR_LENGTH=1</span><br></pre></td></tr></table></figure><p>更多可参看: <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes">主题</a>、<a href="https://github.com/mbadolato/iTerm2-Color-Schemes">色系</a></p><p>ps: 由于 git 是默认安装的插件，而且 ~/.zshrc 中是默认的高亮，满足了基本使用。如果需要安装插件，请自行 <a href="https://www.google.com" target="_blank" rel="noopener">google</a> 。刚接触的时候，迷恋插件，然后找到 Github 上的脚本安装，将 Vim 打造成了炫酷的 IDE 效果，由于不熟悉操作，放弃之，自此远离非必要插件，需求驱动安装插件我觉得是新手最佳选择.</p>]]></content>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> iTerm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/12/10/hello-world/"/>
      <url>/2017/12/10/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h2 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h2 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h2 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h2 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Android MAT分析内存</title>
      <link href="/2015/01/27/Android-MAT%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98/"/>
      <url>/2015/01/27/Android-MAT%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>本篇文章是第一次分析 App 内存的一次记录，使用了一些简单的 <code>adb</code> 命令以及 <code>MAT</code> 工具对内存文件进行分析，对简单的一些内存问题进行了举例说明。<br>这篇文章第一次发布在 CSDN ，由于 CSDN 已长期不维护，所以迁移到此处。 最近还会对内存进行深入研究，所以自己也顺带看看以前的青涩思路。</p><a id="more"></a><h1 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h1><p>使用adb dumpsys 命令<br>adb是一个非常强大的工具，使用adb查看应用程序内存使用情况可按如下格式在命令行里查看内存使用情况：<br><code>adb shell dumpsys meminfo &lt;package_name&gt;</code></p><p>还有些有用的命令</p><ol><li>adb shell dumpsys activity—————查看ActvityManagerService 所有信息</li><li>adb shell dumpsys activity activities———-查看Activity组件信息</li><li>adb shell dumpsys activity services———–查看Service组件信息</li><li>adb shell dumpsys activity providers———-产看ContentProvider组件信息</li><li>adb shell dumpsys activity broadcasts——–查看BraodcastReceiver信息</li><li>adb shell dumpsys activity intents————–查看Intent信息</li><li>adb shell dumpsys activity processes———查看进程信息</li></ol><p>其中，package_name 也可以换成程序的pid，pid可以通过 adb shell top | grep app_name 来查找</p><p>重点关注如下几个字段：<br> （1） Native/Dalvik 的 Heap 信息<br>具体在上面的第一行和第二行，它分别给出的是JNI层和Java层的内存分配情况，如果发现这个值一直增长，则代表程序可能出现了内存泄漏。</p><p> （2） Total 的 PSS 信息<br>这个值就是你的应用真正占据的内存大小，通过这个信息，你可以轻松判别手机中哪些程序占内存比较大了。</p><p>命令输入后还有以下信息：<br>   <img src="http://upload-images.jianshu.io/upload_images/2143211-5969138308a1052c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><ul><li><p>横竖屏或者切屏观察activity数目变化，Activity发生重建且上面标记处数目增加，那么就表示该activity未被回收，存在内存泄漏。 *</p><p> <img src="http://upload-images.jianshu.io/upload_images/2143211-3e8178261e030726?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><p>导出的文件并不能直接被MAT工具解析，需要用工具转换。工具地址：D:\sdk\tools\hprof-conv.exe<br>   命令输入：</p><pre><code>D:\sdk\tools\hprof-conv.exe        D:\mat_any\com.lenovo.tabletstore.hprof     D:\mat_any\my.hprof工具路径---&gt;直接导出文件的路径---&gt;希望转换后存储文件名及路径</code></pre><p>接下来用MAT分析该文件，<a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">下载地址</a> ；<a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">文档介绍</a></p></li></ul><h1 id="内存泄漏分析"><a href="#内存泄漏分析" class="headerlink" title="内存泄漏分析"></a>内存泄漏分析</h1><p>通过对网上资料整理，发现还是下面的方法比较简洁好用</p><p>  <img src="http://upload-images.jianshu.io/upload_images/2143211-5ea5fb7adb682b4c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><p>打开MAT找到标记按钮，输入查找数据库指令</p><p><code>select * from instanceof android.app.Activity</code></p><p>按Ctrl + F5或者! 或者 F5</p><p>操作可以参考 这篇文章 ：<a href="http://www.jianshu.com/p/c49f778e7acf" target="_blank" rel="noopener">使用Android studio分析内存泄露</a></p><p>个人建议：<br>如果搜索出来的同一个activity只有一个（前提是确定该activity确实发生多次重建），那么可以忽略，但是最好还是看下是否有自己熟悉的泄漏；如果存在多个相同的activity，那么理论上 这个字段小的 是应该被回收的Activity。所以要选中这些应被回收而未被回收的Activity进行上述的操作    右键–&gt;Path To Gc Roots –&gt; exclude weak/soft reference</p><p>提供本人遇到的几个泄漏问题：</p><p><1> Context 被引用，未被回收，所以在能用ApplicationContext的地方尽量使用ApplicationContext<br>       使用场景参考  <a href="http://blog.csdn.net/lmj623565791/article/details/40481055" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/40481055</a>   Android Context 上下文 你必须知道的一切</1></p><p><2> Listener 自己添加的  需要自己去解除引用<br>   <img src="http://upload-images.jianshu.io/upload_images/2143211-c010c9e84287213d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></2></p><p><img src="http://upload-images.jianshu.io/upload_images/2143211-60defa0da2c586cc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><p><3> 使用弱引用时应该注意返回弱引用中取出的对象，将强引用释放，而不是直接返回强引用对象</3></p><p>  <img src="http://upload-images.jianshu.io/upload_images/2143211-f264e8b46aedbef8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"><br><img src="http://upload-images.jianshu.io/upload_images/2143211-eb452ad8f40fae59?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><p><strong>最后需要根据分析的结果去排查泄漏的地方，如果看不懂分析结果，可以自己拿到该对象去代码中排查，对每一个引用点进行细致分析，是否会存在异步问题导致比Activity生命周期存在时间长而产生内存泄漏，以及存储的集合是否需要手动清空等等…</strong></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
            <tag> MAT </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
